#provide "g.put"

///Section: g

include "matrix"
include "transform"
include "constraints"

// Object providing a subset of functionality of Put.
// In particular this object allows only to manually place figures.
// (Undocumented as it is not expected to be used directly. Use Put, instead!)
SimplePut = ++(Window src, Matrix matrix)
Matrix@SimplePut[.matrix = $]
Transform@SimplePut[.matrix = $.GetMatrix[]]
Window@SimplePut[.src = $]
SimplePut@Window "Box_Lib_G_SimplePut_At_Window" ?
SimplePut@Valid[$.src]

// The idea above is that Put contains an intermediate window (Put.target)
// where figures are put cumulatively on (;)@Put. Put@Window is then
// implemented by just passing Put.target to the Window.
// This allows putting many figures with just one Put usage.
// NOTE: one may argue whether we should split Put into two subobjects:
//   Put and Puts, similarly to what is done for Circle and Circles, etc.
//   (this would avoid an extra Window@Window step and improve performance)

///Intro: put {type(Window)} objects inside other {type(Window)} objects.
// The {type(Put)} object allows to transform manually (by giving translation
// vectors or rotation angles) or automatically (by giving {type(Near)}
// constraints) a source figure and put it inside a target figure.
Put = ++(Constraints constraints
         Transform transform
         SimplePut simple_put
         Window target)

(.[)@Put[.target = Window[]]

///Intro: place the figure as specified so far and start a new specification.
// This is useful to place many figures with just one {type(Put)} instruction.
(;)@Put[
  // Check whether the source window was given.
  [If[!Valid[$$.simple_put]]
     Fail["You did not provide a source Window to Put"]]

  // First we output the window to Put.target (the intermediate window)
  [If[Num[$$.constraints] > 0]
     \ $$.transform[$$.constraints]]
  \ $$.target[$$.simple_put[$$.transform]]

  // Then we map the list of hot points
  src = $$.simple_put.src   // <-- this does not duplicate the Window
  n = Num[$$.simple_put.src]
  i = 0
  [If[i < n]

     // Add the mapped hot point
     \ $$.target[
       Hot[$$.simple_put.matrix.Apply[src.Get[i]]
           [If[src.HasNamedHotPoint[i]], src.GetHotPointName[i]];]
     ]

   i += 1
   For[1]]

   // The figure has been placed already.
   $$.simple_put.src = Window[]
]

(])@Put[;]

///Intro: Provide the allowed transformations for the automatic placing
// of figures. This is a string made of several letters. Each letter specifies
// an allowed transformation.  For example: ``"rt"`` means that "r"otations
// and "t"ranslations are allowed. The algorithm will then try to rotate
// and translate the source figure until the {type(Near)} constraints are best
// satisfied. The order of letters does not matter, e.g.  ``"rt"`` is
// equivalent to ``"tr"``. The correspondence letter -> transformation is as
// follows: ``"t"`` -> translation, ``"r"`` -> rotation, ``"s"`` -> scale,
// ``"a"`` -> allows anisotropic scaling, ``"i"`` -> allows inversion
// (mirroring).  It is also possible to use ``"tx"`` or ``"ty"`` to enable
// translation only along one of the axes.
// It is also possible to give sign ``"+"`` and ``"-"``. The sign
// changes the behaviour of the function. ``"+"`` means that the following
// characters should be used to enable transformations (default), while ``"-"``
// means that they should be used to disable transformations. This is handy for
// concatenated strings. Example: ``allowed + "-txr"`` means that we should do
// whathever specified by ``allowed``, but we should not translate along-x nor
// rotate.  There are then a few characters to fine tune the behaviour of the
// function.  When ``string`` starts with a white space ``" "``, the flags are
// or-ed over the pre-existing settings (while if the string does not start
// with a space previous values are ignored, i.e. set to zero). Spaces in the
// middle of the string are ignored.         
Str@Put[\ .constraints[$]]

///Intro: provide a {type(Near)} constraint to place the source figure.
// The figure will be transformed as specified by the string in {comb(Str@Put)}
// until the {type(Near)} constraints are best satisfied.
Near@Put[\ .constraints[$]]

///Intro: provide a {type(Matrix)} for placing the figure manually.
// This should be used only for manual placing of figures. You should provide
// a {type(Transform)} object to provide a starting transformation to the
// automatic placing algorithm.
Matrix@Put[\ .transform[$]]

///Intro: provide an initial transformation to the placing algorithm.
// Note that you can often provide the transformation details directly to
// {type(@.)}. For example, you can use ``Put[..., Center[c], p]`` rather
// than ``Put[..., Transform[Center[c], p]]``. If you decide to go for the
// latter, then you should remember that every {comb(Transform@Put)}
// specification overrides entirely the previous one.
Transform@Put[.transform = $]

///Intro: provide the translation vector.
// This is similar to {comb(.@Transform)}.
Point@Put[\ .transform[$]]
Translation@Put[\ .transform[$]] ///Same.

///Intro: provide the scale factors.
// This is similar to {comb(.@Transform)}.
Scale@Put[\ .transform[$]]

///Intro: provide the scale factor (for isotropic scaling).
// This is similar to {comb(.@Transform)}.
Real@Put[\ .transform[$]]

///Intro: provide the rotation angle.
// This is similar to {comb(.@Transform)}.
Angle@Put[\ .transform[$]]

///Intro: provide the center of rotation.
// This is similar to {comb(.@Transform)}.
Center@Put[\ .transform[$]]

///Intro: provide the figure to be placed.
Window@Put[\ .constraints[$], .simple_put.src = $]

///Intro: output the content of {type(Put)} into the given {type(Window)}.
Put@Window[\ $[;], $.target]

///Intro: get a {type(Hot)} point of the transformed {type(Window)} objects.
Put.Get = Point

///Intro: provide the index, similarly to {comb(Window@Get)}.
Int@Put.Get[$$ = $$$.target.Get[$]]
REAL@Put.Get[$$ = $$$.target.Get[$]]  ///Same.
Point@Put.Get[$$ = $$$.target.Get[$]] ///Same.
Str@Put.Get[$$ = $$$.target.Get[$]]   ///Same.
