#provide "g.poly"
///Section: g

include "raw"
include "style"
include "path"
include "points"

///Intro: polygonal shape (supports corner rounding).
Poly = ++(Points points
          Obj margins
          (Real left, right) margin
          Int num_margins
          Int close
          Style style)

(.[)@Poly[.close = 0, .num_margins = 0, $$.margin = (0.0, 0.0)]

///Intro: real number between 0 and 1 used to round the corners of the
// polygon. 0.0 gives sharp corners, 0.5 gives smooth corners, 1.0 gives
// alternating smooth and sharp corners.
Real@Poly[
  [If[$$.num_margins == 0]
     $$.margin.left = ml = Max[0.0, Min[1.0, $]]
     $$.margin.right = Max[0.0, Min[1.0 - ml, ml]]
   Else[], If[$$.num_margins == 1]
     $$.margin.right = Max[0.0, Min[1.0 - $$.margin.left, $]]
   Else[], Fail["Only two margins can be given between two points!"]]
  $$.num_margins += 1
]

///Intro: next vertex of the polygon.
Point@Poly[
  // Store margins and point
  \ .points[$]
  \ .margins[($$.margin.left, $$.margin.right)]

  // Swap margins by default for new vertices
  $$.num_margins = 0
  $$.margin.right = Real[$$.margin.left, $$.margin.left = $$.margin.right]
]

///Intro: the number of vertices of the polygon.
Poly@Num[$.points]

///Intro: add the points of the {type(.@)} object.
Poly@Points[$.points]

///Intro: retrieve a vertex of the polygon (or intermediate points).
Poly.Get = Point

///Intro: get the polygon vertex having the given index.
Int@Poly.Get[$$ = $$$.points.Get[$]]

///Intro: interpolate the vertex (see {type(Points.Get)}).
REAL@Poly.Get[$$ = $$$.points.Get[$]]

///Intro: interpolate the vertex (see {type(Points.Get)}).
Point@Poly.Get[$$ = $$$.points.Get[$]]

//NOTE: BUG: the following doesn't work!
//  Int@Poly.Get[$$ = Point[$$$.args.Get[2 + 3*$]]]

///Intro: color to use for filling the polygon.
Color@Poly[\ .style[$]]

///Intro: gradient used for filling the polygon.
Gradient@Poly[\ .style[$]]

///Intro: style to use when drawing the polygon.
Style@Poly[\ .style[$]]

///Intro: add the polygon to the path.
Poly@Path[
  num_vertices = Num[$.points]
  If[num_vertices >= 3]
    // Correct margins (this is quite tricky, but is needed to get Poly behave
    // how the user expects)
    num_margins = $.num_margins
    margins_at_0 = Point[$.margins.Get[0], .x=$.margin.left
                         If[num_margins > 1], .y=$.margin.right]

    vertex0 = $.points.Get[-2]
    vertex1 = $.points.Get[-1]
    prev_margin = Point[$.margins.Get[num_vertices - 1]].y
    point0 = vertex1 + (vertex0 - vertex1)*prev_margin

    Obj[const.raw.move_to, point0]

    i = 0
    [If[i < num_vertices]
       vertex2 = Point[$.points.Get[i]]
       margins = Point[If[i > 0], $.margins.Get[i]
                       Else[], margins_at_0]
       margin_left = margins.x
       margin_right = margins.y

       degenerate_corner = (prev_margin == 0.0) || (margin_left == 0.0)

       segment_vector = vertex2 - vertex1
       point1 = vertex1 + margin_left*segment_vector
       point2 = vertex2 - margin_right*segment_vector

       [If[degenerate_corner]
          [If[prev_margin != 0.0]
             Obj[const.raw.line_to, vertex1]]
          Obj[const.raw.line_to, point2]
        Else[]
          Obj[const.raw.ext_joinarc_to, point0, vertex1, point1]
          Obj[const.raw.line_to, point2]]

       prev_margin = margin_right
       point0 = point2
       vertex0 = vertex1
       vertex1 = vertex2
     i += 1, For[1]]

    // Close the polygon, if requested
    [If[$.close], Obj[const.raw.close_path]]

    // Mark the path as "non empty"
    .empty = 0
]

///Intro: pass the polygon to the window for drawing.
Poly@Window[
  path = Path[$]
  If[!path.empty]
    path.cmdstream
    CmdStream[$.style]
]

///Intro: close a polygon.
Close = ++Void

///Intro: close the polygon.
Close@Poly[.close = 1]
