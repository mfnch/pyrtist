#provide "g.curve"
///Section: g

include "raw"
include "style"
include "path"

Miss = ^Void

///Intro: Extension of {type(Point)} which allow to specify an entering and
// exiting direction.
Tri = ^(Int have, num, Point p, pin, pout)

(.[)@Tri[.have = 0, .num = 0]

///Intro: The entering, central or exiting point.
Point@Tri[
  num = .num++
  If[num == 0], .pin = .p = .pout = $, .have = 2
  Else, If[num == 1], .pin = .p, .pout = .p = $, .have = (.have >> 1) | 2
  Else, If[num == 2], .pout = $, .have |= 4
  Else, Fail["Tri does take up to three points"]
]

Miss@Tri[num = .num++, If[num == 1], .pin = .p, .have >>= 1]

///Intro: copy the {type(Tri)} object from the given one.
Tri@Tri[$$ = $]

///Intro: curved polygon.
Curve = ^(Array tris, Int close, Style style)

(.[)@Curve[.close = 0]

///Intro: whether to close the curved polygon.
Close@Curve[.close = 1]

///Intro: provide the next point (optionally, with directions).
(Point=>Tri)@Curve[\ .tris[$]]

///Intro: pattern to use for filling the polygon.
Pattern@Curve[\ .style[$]]

///Intro: style to use when drawing the polygon.
Style@Curve[\ .style[$]]

///Intro: append the curve path.
Curve@Path[
  num = Num[$.tris]
  If[num >= 2]
    first_tri = prev_tri = Tri[Get[$.tris, 0]]
    Obj[const.raw.move_to, prev_tri.p]

    i = 1
    [If[i < num]
       tri = Tri[Get[$.tris, i]]
       Obj[const.raw.curve_to, prev_tri.pout, tri.pin, tri.p]
       prev_tri = tri
     i += 1, For[1]]
   
     [If[$.close]
       Obj[const.raw.curve_to, prev_tri.pout, first_tri.pin, first_tri.p]]
     $$.empty = 0
]

///Intro: pass the polygon to the window for drawing.
Curve@Window[
  path = Path[close = $.close, $.close = 1, $, $.close = close]
  If[!path.empty]
    path.cmdstream
    CmdStream[$.style]
]
