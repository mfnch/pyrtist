#provide "g.put"

///Section: g

///Intro: constraint used by {type(Put)} to compute transformation matrices.
Near = ++((Int src, dst) have
          Str src_name, Point src
          Point dst
          Real weight)

(.[)@Near[.have = (0, 0)]

///Intro: the name of the hot point in the source figure.
Str@Near[
  [If[$$.have.src]
     Fail["Near[] already received the source point."]]
  $$.src_name = $
  $$.have.src = 2
]

///Intro: provide source and destination points.
Point@Near[
  [If[$$.have.src == 0], $$.src = $, $$.have.src = 1
   Else[], If[$$.have.dst == 0], $$.dst = $, $$.have.dst = 1
   Else[]
     Fail["Near[] got both the source and the destination points."]]
]

///Intro: provide the weight for the {type(Near)} constraint.
Real@Near[.weight = $]

///Intro: whether a {type(Near)} constraint is complete.
// A Near constraint is complete when it has both a source hot point and
// a destination point.
Near.Completed = Int

([)@Near.Completed[$$ = $$$.have.src && $$$.have.dst]

///Intro: put {type(Window)} objects inside other {type(Window)} object.
// The {type(Put)} object allows to transform manually (by givin translation
// vectors or rotation angles) or automatically (by giving constraints through
// the {type(Near)} object) a source figure and put it inside a target figure.
Put = ++(Window window,)

///Intro: provide a {type(Near)} constraint to place the source figure.
Near@Put[
  [If[!$.Completed[]], Fail["Put got an incomplete Near constraint."]]  
]

///Intro: Provide the allowed transformations for the automatic placing
// of figures.
// This is a string made of several letters. Each letter specifies an allowed
// transformation. For example ``"rt"`` means that the algorithm should try
// rotate and translate the source figure until the {type(Near)} constraints
// are best satisfied. The available letters are ``t`` for translation,
// ``r`` for rotation, ``s`` for scale.
Str@Put[]
