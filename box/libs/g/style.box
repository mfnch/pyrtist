#provide "g.style"
///Section: g

include "raw"
include "cmdstream"
include "pattern"
include "gradcore"
include "option"

///Intro: the dash pattern for tracing lines.
Dash = ++((Int semicolon,) have, Real offset, Obj dashes)

(.[)@Dash[.have.semicolon = 0, .offset = 0.0]

///Intro: before the semicolon (e.g ``Dash[1.0, 2.0; ...]``
// specify alternatively the length of dash, of the following space, etc.
// After the semicolon (e.g. ``Dash[...; 1.5]``) specifies the offset,
// which determines where the patter starts with respect to the first point
// in the path.
Real@Dash[If[$$ .have.semicolon], .offset = $, Else[], \ .dashes[$]]

///Intro: communicates that the dash pattern has been entered and that the
// offset is about to follow.
(;)@Dash[If[$$.have.semicolon], Fail["Dash already got a semicolon"]
         Else[], .have.semicolon = 1]

///Intro: add the graphic commands encoding a ``Dash`` object.
Dash@CmdStream[
  n = Num[$.dashes]
  If[n > 0]
    Obj[const.raw.set_dash, $.offset
        i = 0
        Obj[If[i < n], Real[$.dashes.Get[i]], i += 1, For[1]]]
]

join_options = Options[
  Option["none", -1]
  Option["miter", const.line.join.miter]
  Option["round", const.line.join.round]
  Option["bevel", const.line.join.bevel]
]

///Intro: join style.
// Controls how the segments in a line are joined together.
Join = ++(Int int,)

(.[)@Join[.int = -1]

///Intro: provide the join style as an integer.
// Can be either ``const.line.join.miter``, ``const.line.join.round``,
// ``const.line.join.bevel``.
Int@Join[.int = $]

///Intro: provide the join style as a string.
// Can either be ``"miter"``, ``"round"`` or ``"bevel"``.
Str@Join[join_options.GetInt[$]]

///Intro: get the command for setting the join style.
Join@CmdStream[If[$.int >= 0], Obj[const.raw.set_line_join, $.int]]

cap_options = Options[
  Option["none", -1]
  Option["butt", const.line.cap.butt]
  Option["round", const.line.cap.round]
  Option["square", const.line.cap.square]
]

///Intro: cap style.
// Controls how lines are capped (how they begin and end).
Cap = ++(Int int,)

(.[)@Cap[.int = -1]

///Intro: provide the cap style as an integer.
// Can be either ``const.line.cap.butt``, ``const.line.cap.round``,
// ``const.line.cap.square``.
Int@Cap[.int = $]

///Intro: provide the cap style as a string.
// Can either be ``"butt"``, ``"round"`` or ``"square"``.
Str@Cap[cap_options.GetInt[$]]

///Intro: get the command for setting the cap.
Cap@CmdStream[If[$.int >= 0], Obj[const.raw.set_line_cap, $.int]]

///Intro: miter limit.
// If the current line join style (see {type(Join)}) is set to "miter", the
// miter limit (a real number) is used to determine whether the lines should
// be joined with a bevel instead of a miter. This is determined in by dividing
// the miter by the line width. If the result is greater than the miter limit,
// then the style is converted to a bevel.
MiterLimit = ++(Real real,)

(.[)@MiterLimit[.real = -1.0]

///Intro: provide the value for the miter limit.
// Use a negative value to unset the MiterLimit.
Real@MiterLimit[.real = $]

///Intro: get the command for setting the miter limit.
MiterLimit@CmdStream[If[$.real >= 0.0], Obj[const.raw.set_miter_limit, $.real]]

///Intro: border width and color to be used when tracing the next
// polygon (for {type(Poly)}, {type(Circle)}, etc).
Border = ++((Int color, width, dash) have
            Pattern pattern, Real width, Dash dash, Join join, Cap cap
            MiterLimit miter_limit
            Color color)

//^^^ NOTE: The member Border.color is somewhat redundant (as pattern already
// contains the color specification). We keep this to make it easy to convert
// a Style object to an OldStyle object (i.e. for compatibility with the old
// interface). At some point we will remove OldStyle and also Border.color.

(.[)@Border[.have = (0, 0, 0), .width = 0.0]

///Intro: specify the border width.
Real@Border[.width = $, .have.width = 1]

///Intro: specify the border color.
Color@Border[.color = $, \ $$.pattern[$], .have.color = 1]

///Intro: specify the join style.
Join@Border[.join = $]

///Intro: set the miter limit.
MiterLimit@Border[.miter_limit = $]

///Intro: specify the cap style.
Cap@Border[.cap = $]

///Intro: use a gradient to render the border.
Gradient@Border[\ $$.pattern[$], .have.color = 1]

///Intro: merge the border specification.
Border@Border[
  [If[$.have.width], $$.width = $.width, $$.have.width = 1]
  [If[$.have.color]
     $$.pattern = $.pattern, $$.color = $.color, $$.have.color = 1]
  [If[$.have.dash], $$.dash = $.dash, $$.have.dash = 1]
  $$.cap = $.cap
  $$.join = $.join
  $$.miter_limit = $.miter_limit
]

///Intro: add the dash pattern specification to the border.
Dash@Border[.dash = $, .have.dash = 1]

///Intro: add the graphicals commands encoding a ``Border`` object.
Border@CmdStream[
  Obj[const.raw.save]
  [If[$.have.color]
     $.pattern
     Obj[const.raw.set_source]
     Obj[const.raw.pattern_destroy]]

  [If[$.have.width], w = $.width, If[w >= 0.0]
     Obj[const.raw.set_line_width, w]]

  [If[$.have.dash], $.dash]

  $.join, $.cap, $.miter_limit

  Obj[const.raw.stroke]
  Obj[const.raw.restore]
]

///Intro: fill style.
FillStyle = ++(Int style,)

(.[)@FillStyle[.style = -2]  // -2 means: unspecified

///Intro: the fill style. One of the following: "void", "plain", "eo".
// "void" indicates that the polygons should not be filled.
// "plain" indicates normal filling, while "eo" indicates even-odd filling.
Str@FillStyle[
  If[Compare[($, "void")] == 0], .style = -1
  Else[], If[Compare[($, "plain")] == 0], .style = const.fill_rule.winding
  Else[], If[Compare[($, "eo")] == 0], .style = const.fill_rule.even_odd
  Else[]
    Fail["Unknown fill style. Known styles: \"void\", \"plain\", \"eo\""]
]

///Intro: a container of drawing style settings.
// A {type(Style)} object determines the style for tracing the next polygon
// (for {type(Poly)}, {type(Circle)}, etc).
Style = ++((Int border, color) have
           FillStyle fill_style, Border border, Pattern pattern, Color color)

(.[)@Style[.have = (0, 0)]

///Intro: set the {type(.@)} used for filling.
Color@Style[$$.color = $, \ $$.pattern[$], .have.color = 1]
Gradient@Style[\ $$.pattern[$], .have.color = 1] ///Same.

///Intro: add the border settings to the {type(@.)} object.
Border@Style[.border = $, .have.border = 1]

///Intro: add the fill style to the {type(@.)} object.
FillStyle@Style[.fill_style = $]

///Intro: copy the style settings from another {type(Style)} object.
Style@Style[
  [If[$.have.color]
     $$.have.color = 1, $$.color = $.color, $$.pattern = $.pattern]
  [If[$.have.border], $$.have.border = 1, $$.border = $.border]
]

///Intro: translate the style object into raw commands.
Style@CmdStream[
  do_stroke = $.have.border

  // Commands for filling
  [If[$.have.color]
     $.pattern
     Obj[const.raw.set_source]
     Obj[const.raw.pattern_destroy]]

  Obj[If[do_stroke], const.raw.fill_preserve
      Else[], const.raw.fill]

  // Commands for the style of the border
  [If[$.have.border], $.border]
]

///Intro: send the style setting to the window.
Style@Window[CmdStream[$]]

///Intro: send the border setting to the window.
Border@Window[CmdStream[$]]

///Intro: an alias for {type(Border)}.
StrokeStyle = Border

//-------------PROVIDED FOR COMPATIBILITY WITH box 0.2.3------------------//

///Intro: fill style (for compatibility with Box 0.2.3).
Style.Fill = Void
Str@Style.Fill[\ $$$.fill_style[$]]

///Intro: border (for compatibility with Box 0.2.3).
Style.Border = Void

///Intro: provided for compatibility with Box 0.2.3.
// See {type(Border)} instead.
Real@Style.Border[\ $$$.border[$], $$$.have.border = 1]
Color@Style.Border[\ $$$.border[$], $$$.have.border = 1] ///Same.

Style.Border.Dash = Void
Real@Style.Border.Dash[
  \ $$$$.border.dash[$]
  $$$$.have.border = $$$$.border.have.dash = 1
]
(;)@Style.Border.Dash[
  $$$$.border.dash.have.semicolon = 1
  $$$$.have.border = $$$$.border.have.dash = 1
]
