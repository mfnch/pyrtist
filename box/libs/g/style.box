#provide "g.style"
///Section: g

include "raw"
include "cmdstream"
include "pattern"
include "gradcore"
include "option"

///Intro: whether default style settings have to be written or preserved.
// This is mostly used internally. It allows to control the scope of validity
// of a Style object. For example, ``Poly[..., Style[Preserve[1], ...]]``
// traces a polygon using the provided style. The style is used only for
// tracing this polygon and does not affect the default style.
// Alternatively, ``Poly[..., Style[Preserve[0], ...]]`` traces the polygon
// using the provided style, which will also become the default style.
// Following ``Poly`` will use this style, unless another style is explicitly
// provided.
Preserve = ^(Int int,)

(.[)@Preserve[.int = -1] // -1 means "unset"

///Intro: 0 means "do not preserve, but rather overwrite the default style",
// 1 means "use this style only for the present shape and preserve the default
// style", -1 means use the default preserve rule.
Int@Preserve[.int = $]

///Intro: the dash pattern for tracing lines.
Dash = ^((Int semicolon,) have, Real offset, Obj dashes)

(.[)@Dash[.have.semicolon = 0, .offset = 0.0]

///Intro: before the semicolon (e.g ``Dash[1.0, 2.0; ...]``
// specify alternatively the length of dash, of the following space, etc.
// After the semicolon (e.g. ``Dash[...; 1.5]``) specifies the offset,
// which determines where the patter starts with respect to the first point
// in the path.
Real@Dash[If[$$ .have.semicolon], .offset = $, Else, \ .dashes[$]]

///Intro: communicates that the dash pattern has been entered and that the
// offset is about to follow.
(;)@Dash[If[$$.have.semicolon], Fail["Dash already got a semicolon"]
         Else, .have.semicolon = 1]

///Intro: add the graphic commands encoding a ``Dash`` object.
Dash@CmdStream[
  n = Num[$.dashes]
  Obj[const.raw.set_dash, $.offset
      i = 0
      [If[i < n], Real[$.dashes.Get[i++]], For[1]]]
]

join_options = Options[
  Option["unset", -1]
  Option["miter", const.line.join.miter]
  Option["round", const.line.join.round]
  Option["bevel", const.line.join.bevel]
]

///Intro: join style.
// Controls how the segments in a line are joined together.
Join = ^(Int int,)

(.[)@Join[.int = -1]

///Intro: provide the join style as an integer.
// Can be either ``const.line.join.miter``, ``const.line.join.round``,
// ``const.line.join.bevel``.
Int@Join[.int = $]

///Intro: provide the join style as a string.
// Can either be ``"miter"``, ``"round"`` or ``"bevel"``.
Str@Join[join_options.GetInt[$]]

///Intro: get the command for setting the join style.
Join@CmdStream[If[$.int >= 0], Obj[const.raw.set_line_join, $.int]]

cap_options = Options[
  Option["unset", -1]
  Option["butt", const.line.cap.butt]
  Option["round", const.line.cap.round]
  Option["square", const.line.cap.square]
]

///Intro: cap style.
// Controls how lines are capped (how they begin and end).
Cap = ^(Int int,)

(.[)@Cap[.int = -1]

///Intro: provide the cap style as an integer.
// Can be either ``const.line.cap.butt``, ``const.line.cap.round``,
// ``const.line.cap.square``.
Int@Cap[.int = $]

///Intro: provide the cap style as a string.
// Can either be ``"butt"``, ``"round"`` or ``"square"``.
Str@Cap[cap_options.GetInt[$]]

///Intro: get the command for setting the cap.
Cap@CmdStream[If[$.int >= 0], Obj[const.raw.set_line_cap, $.int]]

///Intro: miter limit.
// If the current line join style (see {type(Join)}) is set to "miter", the
// miter limit (a real number) is used to decide whether the lines should
// be joined with a bevel instead of a miter. This is determined by dividing
// the miter by the line width. If the result is greater than the miter limit,
// then the style is converted to a ``Join["bevel"]``.
MiterLimit = ^(Real real,)

(.[)@MiterLimit[.real = -1.0]

///Intro: provide the value for the miter limit.
// Use a negative value to unset the MiterLimit.
Real@MiterLimit[.real = $]

///Intro: get the command for setting the miter limit.
MiterLimit@CmdStream[If[$.real >= 0.0], Obj[const.raw.set_miter_limit, $.real]]

///Intro: border width and color to be used when tracing the next
// polygon (for {type(Poly)}, {type(Circle)}, etc).
Border = ^((Int color, width, dash) have, Preserve preserve
           Pattern pattern, Real width, Dash dash, Join join, Cap cap
           MiterLimit miter_limit
           Color color)

//^^^ NOTE: The member Border.color is somewhat redundant (as pattern already
// contains the color specification). We keep this to make it easy to convert
// a Style object to an OldStyle object (i.e. for compatibility with the old
// interface). At some point we will remove OldStyle and also Border.color.

(.[)@Border[.have = (0, 0, 0), .width = 0.0]

///Intro: whether to preserve the default border style or overwrite it.
// See {type(Preserve)} for more information on style preservation.
Preserve@Border[.preserve = $]

///Intro: specify the border width.
Real@Border[.width = $, .have.width = 1]

///Intro: specify the join style.
Join@Border[.join = $]

///Intro: set the miter limit.
MiterLimit@Border[.miter_limit = $]

///Intro: specify the cap style.
Cap@Border[.cap = $]

///Intro: use a gradient to render the border.
(Gradient=>PATTERN)@Border[$$.pattern = $, .have.color = 1]

///Intro: specify the border color.
Color@Border[.color = $, \ $$.pattern[$], .have.color = 1]

///Intro: merge the border specification.
Border@Border[
  [If[$.preserve.int >= 0], $$.preserve = $.preserve]
  [If[$.have.width], $$.width = $.width, $$.have.width = 1]
  [If[$.have.color]
     $$.pattern = $.pattern, $$.color = $.color, $$.have.color = 1]
  [If[$.have.dash], $$.dash = $.dash, $$.have.dash = 1]
  $$.cap = $.cap
  $$.join = $.join
  $$.miter_limit = $.miter_limit
]

///Intro: add the dash pattern specification to the border.
Dash@Border[.dash = $, .have.dash = 1]

///Intro: add the graphicals commands encoding a ``Border`` object.
Border@CmdStream[
  do_preserve = $.preserve.int
  [If[do_preserve], Obj[const.raw.save]]

  [If[$.have.color]
     $.pattern
     Obj[const.raw.set_source]
     Obj[const.raw.pattern_destroy]]

  [If[$.have.width], w = $.width, If[w >= 0.0]
     Obj[const.raw.set_line_width, w]]

  [If[$.have.dash], $.dash]

  $.join, $.cap, $.miter_limit

  Obj[const.raw.stroke]
  [If[do_preserve], Obj[const.raw.restore]]
]

///Intro: fill style.
FillStyle = ^(Int style,)

(.[)@FillStyle[.style = -2]  // -2 means: unspecified

///Intro: the fill style. One of the following: "void", "plain", "eo".
// "void" indicates that the polygons should not be filled.
// "plain" indicates normal filling, while "eo" indicates even-odd filling.
Str@FillStyle[
  If[Compare[($, "void")] == 0], .style = -1
  Else, If[Compare[($, "plain")] == 0], .style = const.fill_rule.winding
  Else, If[Compare[($, "eo")] == 0], .style = const.fill_rule.even_odd
  Else
    Fail["Unknown fill style. Known styles: \"void\", \"plain\", \"eo\""]
]

///Intro: convert a fill rule into a command stream.
FillStyle@CmdStream[If[$.style != -2], Obj[const.raw.set_fill_rule, $.style]]

///Intro: a container of drawing style settings.
// A {type(Style)} object determines the style for tracing the next shape
// (for {type(Poly)}, {type(Circle)}, etc). Settings include: the filling
// color, the border color, width, dash pattern, join style and cap mode.
// There are typically two ways to use a {type(Style)} object. The style
// object can be passed directly to the shape to be drawn. This way the style
// settings are used just once, for the particular considered object.
// For example, ``Poly[Style[...], p1, p2, p3]``.
// Alternatively, the style object can be given to a {type(Window)} object.
// This way the style will become the default style for that window and will
// be used by all the following drawing operations which do not explicitly set
// style attributes. For example, if ``s = Style[Border[1, color.blue]]``,
// then ``Window[][s, Poly[Style[color.red], ...]]`` will produce a red
// polygon with blue border. All shapes following ``s`` in the same window,
// are drawn using this style.
Style = ^((Int border, color) have, Preserve preserve
          FillStyle fill_style, Border border, Pattern pattern, Color color)

(.[)@Style[.have = (0, 0)]

///Intro: whether to preserve the default style or overwrite it.
// See {type(Preserve)} for more information on style preservation.
Preserve@Style[
  .preserve = $
  [If[$$.border.preserve.int < 0]
     $$.border.preserve = $]
]

///Intro: set the pattern used for filling.
Pattern@Style[$$.pattern = $, .have.color = 1] ///<Same.

///Intro: add the border settings to the {type(@.)} object.
Border@Style[\ $$.border[$], .have.border = 1]

///Intro: add the fill style to the {type(@.)} object.
FillStyle@Style[.fill_style = $]

///Intro: copy the style settings from another {type(Style)} object.
Style@Style[
  [If[$.fill_style.style != -2], $$.fill_style = $.fill_style]
  [If[$.preserve.int >= 0], $$.preserve = $.preserve]
  [If[$.have.color]
     $$.have.color = 1, $$.color = $.color, $$.pattern = $.pattern]
  [If[$.have.border], $$.have.border = 1, $.border]
]

///Intro: translate the style object into raw commands.
Style@CmdStream[
  do_preserve = $.preserve.int
  [If[do_preserve]
     Obj[const.raw.save]
     Obj[const.raw.ext_border_save]]

  // Commands for filling
  [If[$.have.color]
     $.pattern
     Obj[const.raw.set_source]
     Obj[const.raw.pattern_destroy]]

  // Fill rule
  $.fill_style

  // Commands for the style of the border
  [If[$.have.border]
     Obj[const.raw.fill_preserve]
     Obj[const.raw.ext_border_exchange]
     $.border
     Obj[const.raw.ext_border_exchange]

   Else
     Obj[const.raw.ext_fill_and_stroke]]

  [If[do_preserve]
     Obj[const.raw.ext_border_restore]
     Obj[const.raw.restore]]
]

///Intro: send the border setting to the window.
Border@Window[CmdStream[$]]

///Intro: an alias for {type(Border)}.
StrokeStyle = Border

include "oldstyle"

OldStyle@Window ?

///Intro: use the drawing style as a default in the next drawing commands.
Style@Window[
  CmdStream[Style[Preserve[0], $]]
  OldStyle[$]
]

///Intro: set the style for lines (the default to be used with {type(Line)}).
StrokeStyle@Window[CmdStream[Border[Preserve[0], $]]]

//-------------PROVIDED FOR COMPATIBILITY WITH box 0.2.3------------------//

///Intro: fill style (for compatibility with Box 0.2.3).
Style.Fill = Void
Str@Style.Fill[\ $$$.fill_style[$]]

///Intro: border (for compatibility with Box 0.2.3).
Style.Border = Void

///Intro: provided for compatibility with Box 0.2.3.
// See {type(Border)} instead.
Real@Style.Border[\ $$$.border[$], $$$.have.border = 1]
Color@Style.Border[\ $$$.border[$], $$$.have.border = 1] ///<Same.

Style.Border.Dash = Void
Real@Style.Border.Dash[
  \ $$$$.border.dash[$]
  $$$$.have.border = $$$$.border.have.dash = 1
]
(;)@Style.Border.Dash[
  $$$$.border.dash.have.semicolon = 1
  $$$$.have.border = $$$$.border.have.dash = 1
]
