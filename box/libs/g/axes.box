#provide "g.axes"

///Section: g

///Intro: a 2D reference system. A {type(.)} object can be created with
// ``Axes[origin, one_zero, zero_one]`` from three points: an origin, the
// position of the point (1, 0) and the position of the point (0, 1).
// If the third point (``zero_one``) is not given, then the point (0, 1) is
// automatically computed as ``origin + Ort[one_zero - origin]``.
Axes = ++(Int state, Point origin, one_zero, zero_one)

(.[)@Axes[
  .state = 0
  .origin = (0.0, 0.0)
  .one_zero = (1.0, 0.0)
  .zero_one = (0.0, 1.0)
]

///Intro: scale the reference system by the given factors.
// Note that the scaling is cumulative.
Scale@Axes[
  scale = Point[$], org = $$.origin
  $$.one_zero = org + scale.x*($$.one_zero - org)
  $$.zero_one = org + scale.y*($$.zero_one - org)
]

///Intro: scale the reference system by the given factors.
// Note that the scaling is cumulative. For example, ``Axes[2, 3]`` is 
// equivalent to ``Axes[2*3]``. 
Real@Axes[Scale[$]]

///Intro: give the points defining the reference system.
Point@Axes[
  state = $$.state
  [If[state == 0]
     $$.origin = $
     $$.one_zero = $ + (1.0, 0.0)
     $$.zero_one = $ + (0.0, 1.0)
   Else, If[state == 1]
     $$.one_zero = $
     $$.zero_one = $$.origin + Ort[$ - $$.origin]
   Else
     $$.zero_one = $]
  $$.state += 1
]

///Intro: the matrix corresponding to the Axes object.
///Example: if ``axes = Axes[origin, one_zero, zero_one]`` and
// ``mx = Matrix[axes]`` then ``mx.Apply[(1, 0)]`` gives ``one_zero``
// and ``mx.Apply[(0, 1)]`` gives ``zero_one``.
Axes@Matrix[
  Matrix[v10 = $.one_zero - $.origin
         v01 = $.zero_one - $.origin
         .m11 = v10.x, .m12 = v01.x, .m13 = $.origin.x
         .m21 = v10.y, .m22 = v01.y, .m23 = $.origin.y]
]
