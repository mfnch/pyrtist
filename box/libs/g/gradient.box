///Section: g

#provide "g.gradient"

include "g"
include "pattern"
include "gradcore"

//NOTE: Gradient is defined in "pattern.box"

///Intro: add a new color to the gradient
Color@Gradient[
  \ $$.colors[$]
  \ $$.offsets[Real[If[$$.have.offset], $$.offset, Else[], -1.0]]
  .have.offset = 0
]

///Intro: the position of the color in the gradient (number between 0 and 1).
// For example, in
// ``Gradient[Line[point1, point2], real1, color1, real2, color2, ...]``
// ``real1`` is the offset (along the line) for ``color1``.
// In other words it is the position in the line (``0`` corresponding to
// ``point1``, and ``1`` to ``point2``) where the gradient becomes equal to
// ``color1``.
Real@Gradient[.offset = Max[0.0, Min[1.0, $]], .have.offset = 1]

///Intro: set the gradient shape to a line.
// The line should have two points and the color will change linearly
// between these two points.
Line@Gradient[
  [If[Num[$] != 2]
     Fail["The line given to Gradient should have exactly 2 points"]]
  .type = 1
  .point1 = $.Get[0]
  .point2 = $.Get[1]
]

///Intro: set the gradient shape to a circle.
Circles@Gradient[
  n = Num[$]
  [If[n != 1 && n != 2]
     Fail["The Circles object given to Gradient " _
          "should contain one or two circles"]]
  .type = 2
  circle1 = $.Get[0]
  circle2 = Circle[If[n >= 2], $.Get[1], Else[], circle1, 0]
  .point1 = circle1.center
  .point2 = circle2.center
  .real1 = circle1.radius
  .real2 = circle2.radius
]

///Intro: use a radial gradient associated to the specified circle.
// ``Gradient[Circle[center, radius], ...]`` is equivalent to
// ``Gradient[Circles[center, 0; radius], ...]``.
Circle@Gradient[
  [If[!IsValid[$]]
     Fail["Circle is not valid (center or radius are missing)."]]
  Circles[$.center, $.radius; 0.0]
]

///Intro: convert the gradient into a generic pattern.
Gradient@PATTERN[
  \ $$.cmdstream[
    If[$.type == 1]
      Obj[const.raw.pattern_create_linear, $.point1, $.point2]
    Else[], If[$.type == 2]
      ctr = $.point1
      refx = Point[ctr, .x += 1.0]
      refy = Point[ctr, .y += 1.0]
      Obj[const.raw.pattern_create_radial
          $.point1, refx, refy, $.point2, $.real1, $.real2]
    Else[]
      Fail[Str["Unknown gradient type (", $.type, ")"]]
  ]

  n = Num[$.colors]
  i = 0

  i0 = -1
  offset0 = 0.0

  [If[i < n]

    // Find (in i) the index of the next color, for which the user has provided
    // an offset.
    [If[Real[$.offsets.Get[i]] < 0.0], i += 1, For[i < n]]

    // Determine the offset of the last color to set. If i >= n, then we have
    // reached the end of the array: we set i to point to the last color and
    // assume the correspodning offset is 1.0.
    offset = Real[If[i < n], $.offsets.Get[i], Else[], 1.0]
    i = Int[If[i < n], i, Else[], n - 1]

    // Set intermediate colors
    m = i - i0
    [
      i0 += 1
      ofs = offset + (i - i0)*(offset0 - offset)/m
      col = Color[$.colors.Get[i0]]
      \ $$.cmdstream[Obj[const.raw.pattern_add_color_stop_rgba,
                         ofs, col.r, col.g, col.b, col.a]]
     For[i0 < i]]

    offset0 = offset
    i += 1
  For[1]]

  \ $$.extend[$.extend]
]

///Intro: set the gradient as the active color.
Gradient@Window[Pattern[$]]

//-------------PROVIDED FOR COMPATIBILITY WITH box 0.2.3------------------//

Gradient.Line = Void

([)@Gradient.Line[$$$.state = 0]

Point@Gradient.Line[
  num_points = $$$.state
  [If[num_points == 0], $$$.point1 = $
   Else[], If[num_points == 1], $$$.point2 = $
   Else[], Fail["Gradient.Line takes exactly two points"]]
  $$$.state += 1
]

(])@Gradient.Line[
  [If[$$$.state != 2]
     Fail["Gradient.Line takes exactly two points"]]
  \$$$[Line[$$$.point1, $$$.point2]]
]

Gradient.Circle = Void

([)@Gradient.Circle[$$$.state = 0]

(;)@Gradient.Circle[
  [If[$$$.state & 0x1], Fail["Gradient.Circle takes just one single `;'"]]
  $$$.state |= 0x1
]

Point@Gradient.Circle[
  got_semicolon = $$$.state & 0x1
  $$$.state |= (0x2 << got_semicolon)
  If[$$$.state & 0x1]
    $$$.point2 = $
  Else[]
    $$$.point1 = $
]

Real@Gradient.Circle[
  got_semicolon = $$$.state & 0x1
  $$$.state |= (0x8 << got_semicolon)
  If[$$$.state & 0x1]
    $$$.real2 = $
  Else[]
    $$$.real1 = $
]

(])@Gradient.Circle[
  [If[($$$.state & 0xa) != 0xa]
     Fail["Gradient.Circle requires a Point (the center) " \
          "and a Real (the radius)"]]

  [If[($$$.state & 0x4) == 0], $$$.point2 = $$$.point1]
  [If[($$$.state & 0x10) == 0], $$$.real2 = 0.0]

  \ $$$[Circles[$$$.point1, $$$.real1; $$$.point2, $$$.real2]]
]
