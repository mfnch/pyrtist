#provide "g.autoput"
///Section: g

include "transform"

///Intro: constraint used by {type(Put)} to compute transformation matrices.
Near = ++((Int src, dst) have
          Str src_name, Point src
          Point dst
          Real weight)

(.[)@Near[.have = (0, 0), .weight = 1.0]

///Intro: the name of the hot point in the source figure.
Str@Near[
  [If[$$.have.src]
     Fail["Near[] already received the source point."]]
  $$.src_name = $
  $$.have.src = 2
]

///Intro: provide source and destination points.
Point@Near[
  [If[$$.have.src == 0], $$.src = $, $$.have.src = 1
   Else[], If[$$.have.dst == 0], $$.dst = $, $$.have.dst = 1
   Else[]
     Fail["Near[] got both the source and the destination points."]]
]

///Intro: provide the weight for the {type(Near)} constraint.
Real@Near[.weight = $]

Near@Str[
  sep = ", "
  "Near["
  [If[$.have.src != 0]
     [If[$.have.src == 1], $.src, Else[], '"', $.src_name, '"']
     [If[$.have.dst != 0], sep, $.dst]]
  [If[$.weight != 1.0], sep, $.weight]
  "]"
]

///Intro: a Near constraint is valid when it has both a source and
// a destination point.
Near@Valid[$.have.src && $.have.dst]

///Intro: a {type(Near)} constraint is complete when it is valid and the
// source point has been resolved to a precise point (coordinate in the plane).
Near.Completed = Int

([)@Near.Completed[$$ = $$$.have.src == 1 && $$$.have.dst == 1]

///Intro: Obj-ify the constraint.
Near@Obj[
  If[Valid[$]]
    Obj[
      [If[$.have.src == 1], $.src
       Else[], $.src_name]
      $.dst, $.weight
    ]
  Else[]
    Fail["Cannot convert Near to Obj. Near object is incomplete."]
]

///Intro: transform an Obj into a Near constraint.
Obj@Near[
  If[$$.have.src == 0 && $$.have.dst == 0]
    src = $.Get[0]
    [If[src.GetType[] == objtype.point], Point[src], Else[], Str[src]]
                    // src ^^^
    Point[$.Get[1]] // dst
    Real[$.Get[2]]  // weight

  Else[]
    Fail["Trying to set a partial Near object from an Obj object"]
]

///Intro: provide the {type(Window)} to which the hot point name refers to.
// The window is used to resolve the Near constraint. For example, if
// the constraint is specified as ``n = Near["name", p1]``, where ``"name"``
// is the name of a {type(Hot)} point of the {type{Window)} ``w``, then
// ``\ n[w]`` transforms ``n`` to ``Near[w.Get["name"], p1]``.
// In other words the named hot point is substituted with the hot point
// coordinates. The window must be provided after the reference to the hot
// point.
Window@Near[
  If[$$.have.src == 2]
    $$.src = $.Get[$$.src_name]
    $$.have.src = 1
]

///Intro: Object containing instructions on how to place objects.
// This object allows to specify how to place a source figure on a destination
// figure. This is done by providing a set of allowed transformations and a set
// of constraints. The idea is to find which of the allowed transformations
// best satisfies the constraints.
Constraints = ++(Str freedom, Obj constraints, Window window)

///Intro: provide the window the constraint refer to.
// The window must be given before any reference to a Hot point is made in the
// constraint list.
// For example, ``Constraints[Near[p1, q1], win, Near["hot-point-1", q2]]``
// (p1, q1 and q2 are {type(Point)} objects) is fine, while
// ``Constraints[Near["hot-point-1", p2], win]`` is not.
Window@Constraints[.window = $]

///Intro: provide the allowed transformations in form of a string.
Str@Constraints[.freedom = $]

///Intro: provide a {type{Near)} constraint.
Near@Constraints[
  [If[Valid[$$.window]], \ $[$$.window]]
  [If[! $.Completed[]]
     msg = Str["The Near constraint ``", $, "'' refers to a hot point "
               "by name, but a valid Window has not been provided, yet."]
     Fail[msg]]
  \ $$.constraints[$]
]

///Intro: compute a transformation matrix from the given constraints.
Constraints@Transform "Box_Lib_G_Constraints_At_Transform" ?
