#provide "g.autoput"
///Section: g

include "transform"

///Intro: constraint used by {type(Put)} and {type(Constraints)} to compute
// transformation matrices.
///Examples: ``Near[src_point, dst_point, weight]``,
//  ``Near["src-name", dst_point, weight]``,
//  ``Near[src_index, dst_point, weight]``.
Near = ^(Obj src_dst, Real weight)

(.[)@Near[.weight = 1.0]

///Intro: the name of the hot point in the source figure.
Str@Near[
  [If[Num[$$.src_dst] > 0]
     Fail["Near[] already received the source point."]]
  \ $$.src_dst[$]
]

///Intro: provide the weight for the {type(Near)} constraint.
Int@Near[
  If[Num[$$.src_dst] > 0], $$.weight = $
  Else, \ $$.src_dst[$]
]

///Intro: provide source and destination points.
Point@Near[
  If[Num[$$.src_dst] < 2], \ $$.src_dst[$]
  Else
    Fail["Near[] got both the source and the destination points."]
]

///Intro: provide the weight for the {type(Near)} constraint.
REAL@Near[.weight = $]

Near@Str[
  sep = ", "
  "Near["
  n = Num[$.src_dst]
  [If[n > 0]
     ot = $.src_dst.GetType[0]
     src = $.src_dst.Get[0]
     [If[ot == objtype.point], Point[src]
      Else, If[ot == objtype.str], '"', Str[src], '"'
      Else, Int[src]]
     [If[n > 1], sep, Point[$.src_dst.Get[1]]]]
  [If[$.weight != 1.0], sep, $.weight]
  "]"
]

///Intro: a Near constraint is valid when it has both a source and
// a destination point.
Near@IsValid[Num[$.src_dst] == 2]

///Intro: a {type(Near)} constraint is complete when it is valid and the
// source point has been resolved to a precise point (coordinate in the plane).
Near.Completed = Int

([)@Near.Completed[
  $$ = (Num[$$$.src_dst] == 2) && ($$$.src_dst.GetType[0] == objtype.point)
]

///Intro: Obj-ify the constraint.
Near@Obj[Obj[Point[$.src_dst.Get[0]], Point[$.src_dst.Get[1]], $.weight]]

///Intro: transform an Obj into a Near constraint.
Obj@Near[
  .src_dst = Obj[Point[$.Get[0]], Point[$.Get[1]]]
  .weight = Real[$.Get[1]]
]

///Intro: provide the {type(Window)} to which the hot point name refers.
// The window is used to resolve the Near constraint. For example, if
// the constraint is specified as ``n = Near["name", p1]``, where ``"name"``
// is the name of a {type(Hot)} point of the {type(Window)} ``w``, then
// ``\ n[w]`` transforms ``n`` to ``Near[w.Get["name"], p1]``.
// In other words the named hot point is substituted with the hot point
// coordinates. The window must be provided after the reference to the hot
// point.
Window@Near[
  n = Num[$$.src_dst]
  [If[n == 2]
     ot = $$.src_dst.GetType[0]
     [If[ot != objtype.point]
        obj = $$.src_dst.Get[0]
        src = $.Get[If[ot == objtype.int], Int[obj], Else, Str[obj]]
        dst = Point[$$.src_dst.Get[1]]
        $$.src_dst = Obj[src, dst]]

   Else
     Fail["Incomplete Near constraint"]]
]

///Intro: Object containing instructions on how to place objects.
// This object allows to specify how to place a source figure on a destination
// figure. This is done by providing a set of allowed transformations and a set
// of constraints. The idea is to find which of the allowed transformations
// best satisfies the constraints.
Constraints = ^(Str freedom, Obj constraints, Window window)

///Intro: number of constraints.
Constraints@Num[$.constraints]

///Intro: provide the window to which the constraints are referring.
// The window must be given before any reference to a Hot point is made in the
// constraint list.
// For example, ``Constraints[Near[p1, q1], win, Near["hot-point-1", q2]]``
// (p1, q1 and q2 are {type(Point)} objects) is fine, while
// ``Constraints[Near["hot-point-1", p2], win]`` is not.
Window@Constraints[.window = $]

///Intro: provide the allowed transformations in form of a string.
// Similar to {comb(Str@Put)}.
Str@Constraints[.freedom = $]

///Intro: provide a {type(Near)} constraint to automatically place the figure.
// Similar to {comp(Near@Put)}.
Near@Constraints[
  [If[IsValid[$$.window]], \ $[$$.window]]
  [If[! $.Completed[]]
     msg = Str["The Near constraint ``", $, "'' refers to a hot point "
               "by name/index, but a valid Window has not been provided, yet."]
     Fail[msg]]
  \ $$.constraints[$]
]

///Intro: compute a transformation matrix from the given constraints.
Constraints@Transform "Box_Lib_G_Constraints_At_Transform" ?
