#provide "g.style"
///Section: g

include "raw"
include "cmdstream"

///Intro: the dash pattern for tracing lines.
Dash = ++((Int semicolon,) have, Real offset, Obj dashes)

(.[)@Dash[.have.semicolon = 0, .offset = 0.0]

///Intro: before the semicolon (e.g ``Dash[1.0, 2.0; ...]``
// specify alternatively the length of dash, of the following space, etc.
// After the semicolon (e.g. ``Dash[...; 1.5]``) specifies the offset,
// which determines where the patter starts with respect to the first point
// in the path.
Real@Dash[If[$$ .have.semicolon], .offset = $, Else[], \ .dashes[$]]

///Intro: communicates that the dash pattern has been entered and that the
// offset is about to follow.
(;)@Dash[If[$$.have.semicolon], Fail["Dash already got a semicolon"]
         Else[], .have.semicolon = 1]

///Intro: add the graphicals commands encoding a ``Dash`` object.
Dash@CmdStream[
  n = Num[$.dashes]
  If[n > 0]
    Obj[g.raw.set_dash, $.offset
        i = 0
        [If[i < n], Real[$.dashes.Get[i]], i += 1, For[1]]]
]

///Intro: border width and color to be used when tracing the next
// polygon (for {type(Poly)}, {type(Circle)}, etc).
Border = ++((Int color, width, dash) have
            Color color, Real width, Dash dash)

(.[)@Border[.have = (0, 0, 0), .width = 0.0]

///Intro: specify the border width.
Real@Border[.width = $, .have.width = 1]

///Intro: specify the border color.
Color@Border[.color = $, .have.color = 1]

///Intro: merge the border specification.
Border@Border[
  [If[$.have.width], $$.width = $.width, $$.have.width = 1]
  [If[$.have.color], $$.color = $.color, $$.have.color = 1]
  [If[$.have.dash], $$.dash = $.dash, $$.have.dash = 1]
]

///Intro: add the dash pattern specification to the border.
Dash@Border[.dash = $, .have.dash = 1]

///Intro: add the graphicals commands encoding a ``Border`` object.
Border@CmdStream[
  Obj[g.raw.save]
  [If[$.have.color]
     c = $.color
     Obj[g.raw.set_source_rgba, c.r, c.g, c.b, c.a]]

  [If[$.have.width], w = $.width, If[w >= 0.0]
     Obj[g.raw.set_line_width, w]]

  [If[$.have.dash], $.dash]

  Obj[g.raw.stroke]
  Obj[g.raw.restore]
]

///Intro: a container of drawing style settings.
// A {type(Style)} object determines the style for tracing the next polygon
// (for {type(Poly)}, {type(Circle)}, etc).
Style = ++((Int border, color) have
           Border border, Color color)

(.[)@Style[.have = (0, 0)]

///Intro: set the filling color.
Color@Style[.color = $, .have.color = 1]

///Intro: add the border settings to the {type(@.)} object.
Border@Style[.border = $, .have.border = 1]

///Intro: copy the style settings from another {type(Style)} object.
Style@Style[
  [If[$.have.color], $$.have.color = 1, $$.color = $.color]
  [If[$.have.border], $$.have.border = 1, $$.border = $.border]
]

///Intro: translate the style object into raw commands.
Style@CmdStream[
  do_stroke = $.have.border

  // Commands for filling
  [If[$.have.color]
     c = $.color, Obj[g.raw.set_source_rgba, c.r, c.g, c.b, c.a]]

  Obj[If[do_stroke], g.raw.fill_preserve
      Else[], g.raw.fill]

  // Commands for the style of the border
  [If[$.have.border], $.border]
]

///Intro: fill style.
FillStyle = ++(Int style,)

(.[)@FillStyle[.style = -1]  // -1 means: unspecified

///Intro: the fill style. One of the following: "void", "plain", "eo".
Str@FillStyle[
  If[0]
  Else[], If[0], .style = g.fill_rule.even_odd
  Else[], If[0], .style = g.fill_rule.winding
  Else[]
    Print["Unknown fill style. Known styles: \"void\", \"plain\", \"eo\"";]
]

///Intro: send the style setting to the window.
Style@Window[CmdStream[$]]

///Intro: send the border setting to the window.
Border@Window[CmdStream[$]]


//-------------PROVIDED FOR COMPATIBILITY WITH box 0.2.3------------------//

///Intro: fill style (for compatibility with Box 0.2.3).
Style.Fill = Void

Str@Style.Fill[]

///Intro: border (for compatibility with Box 0.2.3).
Style.Border = Border

///Intro: provided for compatibility with Box 0.2.3.
// See {type(Border)} instead.
Real@Style.Border[$]
Color@Style.Border[$] ///Same.
