#provide "g.style"
///Section: g

include "raw"
include "cmdstream"
include "pattern"
include "gradcore"

///Intro: the dash pattern for tracing lines.
Dash = ++((Int semicolon,) have, Real offset, Obj dashes)

(.[)@Dash[.have.semicolon = 0, .offset = 0.0]

///Intro: before the semicolon (e.g ``Dash[1.0, 2.0; ...]``
// specify alternatively the length of dash, of the following space, etc.
// After the semicolon (e.g. ``Dash[...; 1.5]``) specifies the offset,
// which determines where the patter starts with respect to the first point
// in the path.
Real@Dash[If[$$ .have.semicolon], .offset = $, Else[], \ .dashes[$]]

///Intro: communicates that the dash pattern has been entered and that the
// offset is about to follow.
(;)@Dash[If[$$.have.semicolon], Fail["Dash already got a semicolon"]
         Else[], .have.semicolon = 1]

///Intro: add the graphic commands encoding a ``Dash`` object.
Dash@CmdStream[
  n = Num[$.dashes]
  If[n > 0]
    Obj[const.raw.set_dash, $.offset
        i = 0
        [If[i < n], Real[$.dashes.Get[i]], i += 1, For[1]]]
]

///Intro: border width and color to be used when tracing the next
// polygon (for {type(Poly)}, {type(Circle)}, etc).
Border = ++((Int color, width, dash) have
            Pattern pattern, Real width, Dash dash
            Color color)

//^^^ NOTE: The member Border.color is somewhat redundant (as pattern already
// contains the color specification). We keep this to make it easy to convert
// a Style object to an OldStyle object (i.e. for compatibility with the old
// interface). At some point we will remove OldStyle and also Border.color.

(.[)@Border[.have = (0, 0, 0), .width = 0.0]

///Intro: specify the border width.
Real@Border[.width = $, .have.width = 1]

///Intro: specify the border color.
Color@Border[.color = $, \ $$.pattern[$], .have.color = 1]

///Intro: use a gradient to render the border.
Gradient@Border[\ $$.pattern[$], .have.color = 1]

///Intro: merge the border specification.
Border@Border[
  [If[$.have.width], $$.width = $.width, $$.have.width = 1]
  [If[$.have.color]
     $$.pattern = $.pattern, $$.color = $.color, $$.have.color = 1]
  [If[$.have.dash], $$.dash = $.dash, $$.have.dash = 1]
]

///Intro: add the dash pattern specification to the border.
Dash@Border[.dash = $, .have.dash = 1]

///Intro: add the graphicals commands encoding a ``Border`` object.
Border@CmdStream[
  Obj[const.raw.save]
  [If[$.have.color]
     $.pattern
     Obj[const.raw.set_source]
     Obj[const.raw.pattern_destroy]]

  [If[$.have.width], w = $.width, If[w >= 0.0]
     Obj[const.raw.set_line_width, w]]

  [If[$.have.dash], $.dash]

  Obj[const.raw.stroke]
  Obj[const.raw.restore]
]

///Intro: fill style.
FillStyle = ++(Int style,)

(.[)@FillStyle[.style = -2]  // -2 means: unspecified

///Intro: the fill style. One of the following: "void", "plain", "eo".
// "void" indicates that the polygons should not be filled.
// "plain" indicates normal filling, while "eo" indicates even-odd filling.
Str@FillStyle[
  If[Compare[($, "void")] == 0], .style = -1
  Else[], If[Compare[($, "plain")] == 0], .style = const.fill_rule.winding
  Else[], If[Compare[($, "eo")] == 0], .style = const.fill_rule.even_odd
  Else[]
    Fail["Unknown fill style. Known styles: \"void\", \"plain\", \"eo\""]
]

///Intro: a container of drawing style settings.
// A {type(Style)} object determines the style for tracing the next polygon
// (for {type(Poly)}, {type(Circle)}, etc).
Style = ++((Int border, color) have
           FillStyle fill_style, Border border, Pattern pattern, Color color)

(.[)@Style[.have = (0, 0)]

///Intro: set the {type(.@)} used for filling.
Color@Style[$$.color = $, \ $$.pattern[$], .have.color = 1]
Gradient@Style[\ $$.pattern[$], .have.color = 1] ///Same.

///Intro: add the border settings to the {type(@.)} object.
Border@Style[.border = $, .have.border = 1]

///Intro: add the fill style to the {type(@.)} object.
FillStyle@Style[.fill_style = $]

///Intro: copy the style settings from another {type(Style)} object.
Style@Style[
  [If[$.have.color]
     $$.have.color = 1, $$.color = $.color, $$.pattern = $.pattern]
  [If[$.have.border], $$.have.border = 1, $$.border = $.border]
]

///Intro: translate the style object into raw commands.
Style@CmdStream[
  do_stroke = $.have.border

  // Commands for filling
  [If[$.have.color]
     $.pattern
     Obj[const.raw.set_source]
     Obj[const.raw.pattern_destroy]]

  Obj[If[do_stroke], const.raw.fill_preserve
      Else[], const.raw.fill]

  // Commands for the style of the border
  [If[$.have.border], $.border]
]

///Intro: send the style setting to the window.
Style@Window[CmdStream[$]]

///Intro: send the border setting to the window.
Border@Window[CmdStream[$]]

///Intro: an alias for {type(Border)}.
StrokeStyle = Border

//-------------PROVIDED FOR COMPATIBILITY WITH box 0.2.3------------------//

///Intro: fill style (for compatibility with Box 0.2.3).
Style.Fill = Void
Str@Style.Fill[\ $$$.fill_style[$]]

///Intro: border (for compatibility with Box 0.2.3).
Style.Border = Void

///Intro: provided for compatibility with Box 0.2.3.
// See {type(Border)} instead.
Real@Style.Border[\ $$$.border[$], $$$.have.border = 1]
Color@Style.Border[\ $$$.border[$], $$$.have.border = 1] ///Same.

Style.Border.Dash = Void
Real@Style.Border.Dash[
  \ $$$$.border.dash[$]
  $$$$.have.border = $$$$.border.have.dash = 1
]
(;)@Style.Border.Dash[
  $$$$.border.dash.have.semicolon = 1
  $$$$.have.border = $$$$.border.have.dash = 1
]
