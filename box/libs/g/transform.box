#provide "g.transform"

///Section: g

include "matrix"

//FIXME: below we define Angle = ++(Real angle,) rather than Angle = ++Real.
// This is because at the moment Box doesn't provide an inverse operator for
// ++ (which takes an increased type object and reduces it to the original
// type). This is a feature which is planned for implementation.
// (the note above holds also for Center, Scale, etc.)

//FIXME: later we would like to implement what follows:
//   (*->Transform)@Matrix[$]
// Whatever can be given to Transform is given to a new Transform object,
// which is then passed to Matrix (this requires the new species
// implementation).

///Intro: Represents an angle in radians.
///Example: ``Angle[const.pi/2]``
Angle = ++(Real angle,)

///Intro: angle in radians.
Real@Angle[.angle = $]

///Intro: return the angle for the given vector.
// See {type(Norm)} for the vector norm.
// In particular,
// ``p = Point[a = Angle[p], Norm[p]*(Cos[a], Sin[a])]``.
Point@Angle[Atan2[$]]

///Intro: Angle to string.
Angle@Str["Angle[", $.angle, "]"]

///Intro: print the Angle.
Angle@Print[Str[$]]

///Intro: retrieve the angle as a real number.
Angle@Real[$.angle]

///Intro: Represents an angle in degrees.
///Example: ``AngleDeg[180]`` is equivalent to ``Angle[const.pi]``
AngleDeg = Angle

///Intro: angle in degrees.
Real@AngleDeg[.angle = $*0.01745329251994329576]

///Intro: AngleDeg to string.
AngleDeg@Str["AngleDeg[", $.angle*180.0/const.pi, "]"]

///Intro: print AngleDeg.
AngleDeg@Print[Str[$]]

///Intro: represent a {type(Point)} in the center of something.
Center = ++(Point center,)
(.[)@Center[.center.x = .center.y = 0.0]

///Intro: the value for the center.
Point@Center[.center = $]

///Intro: Represents the factors for a scale transformation.
Scale = ++(Point scale_factors,)
(.[)@Scale[.scale_factors.x = .scale_factors.y = 1.0]

///Intro: scale isotropically by the given factor.
Real@Scale[.scale_factors.x *= $, .scale_factors.y *= $]

///Intro: scale by the given x and y factors.
Point@Scale[.scale_factors.x *= $.x, .scale_factors.y *= $.y]

///Intro: compose with the provided scaling transformation.
Scale@Scale[$$.scale_factors.x *= $.scale_factors.x
            $$.scale_factors.y *= $.scale_factors.y]

///Intro: retrieve the scale factors in the form of a {type(Point)}.
Scale@Point[$.scale_factors]

///Intro: Represents a translation vector.
Translation = ++(Point translation,)
(.[)@Translation[.translation.x = .translation.y = 0.0]

///Intro: translation vector.
Point@Translation[.translation = $]

///Intro: parametrized {type(Matrix)} object.
// A {type(.)} object represents a transformation of the two dimensional
// coordinate system, parametrized by: a translation vector, a rotation angle
// and rotation center and scaling factors along each dimension.
Transform = ++(Point translation, rotation_center, scale_factors
               Real rotation_angle)

(.[)@Transform[
  .translation = .rotation_center = (0.0, 0.0)
  .scale_factors = (1.0, 1.0)
  .rotation_angle = 0.0
]

///Intro: provide the center of the rotation.
Center@Transform[.rotation_center = $.center]

///Intro: the rotation angle.
Angle@Transform[.rotation_angle = $.angle]

///Intro: the scale factors.
Scale@Transform[.scale_factors = $.scale_factors]

///Intro: the translation vector.
Translation@Transform[.translation = $.translation]

///Intro: the scale factor (for isotropic scaling).
Real@Transform[.scale_factors.x = .scale_factors.y = $]

///Intro: the translation vector.
Point@Transform[.translation = $]

///Intro: compute and return the {type(Matrix)} of the given transformation.
Transform.GetMatrix = Matrix

([)@Transform.GetMatrix[
  rcos = Cos[$$$.rotation_angle], rsin = Sin[$$$.rotation_angle]
  rcenter = $$$.rotation_center, scale = $$$.scale_factors
  translation = $$$.translation

  m11 = scale.x*rcos, m12 = -scale.y*rsin
  m21 = scale.x*rsin, m22 = scale.y*rcos

  $$.m11 = m11, $$.m12 = m12
  $$.m21 = m21, $$.m22 = m22
  $$.m13 = (1.0 - m11)*rcenter.x - m12*rcenter.y + translation.x
  $$.m23 = (1.0 - m22)*rcenter.y - m21*rcenter.x + translation.y
]

///Intro: compute the matrix corresponding to the given transformation.
// Note that the new matrix is applied to the current matrix.
// In other words it does not overwrite it, but is multiplied to it.
// Example: if ``t = Transform[...]``, then ``Matrix[2, t]`` is the matrix
// resulting from the multiplication of ``Matrix[2]`` and ``Matrix[t]``
// and is equivalent to ``Matrix[2, t.GetMatrix[]]``.
Transform@Matrix[$.GetMatrix[]]

///Intro: transform a {type(.@)} into a {type(@.)} assuming (0, 0) as the 
// rotation center.
Matrix@Transform[
  m11 = $.m11, m12 = $.m12, m21 = $.m21, m22 = $.m22
  determinant = m11*m22 - m21*m12
  [If[determinant == 0.0]
     Fail["The matrix is singular (determinant==0.0)"]]
  .scale_factors.x = scalex = Sqrt[m11*m11 + m21*m21]
  .scale_factors.y = determinant/scalex
  .rotation_angle = Atan2[Point[.x=m11, .y=m21]]
  .rotation_center = Point[.x=.y=0.0]
  .translation.x = $.m13
  .translation.y = $.m23  
]
