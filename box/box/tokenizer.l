/***************************************************************************
 *   Copyright (C) 2006 by Matteo Franchin                                 *
 *   fnch@libero.it                                                        *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

%x include
 /* ^^^ Start condition used to extract the file name in include directives */

%{

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "types.h"
#include "defaults.h"
#include "mem.h"
#include "ast.h"
#include "messages.h"
#include "array.h"
#include "str.h"
#include "virtmach.h"
#include "tokenizer.h"
#include "parserh.h"
#include "parser.h" /* This is the file generated by yacc */
#include "builtins.h"
#include "fileutils.h"
#include "paths.h"
#include "hashtable.h"
#include "srcpos.h"

/* Use our message handler */
#define YY_FATAL_ERROR(msg) MSG_FATAL("%s", msg)

/** Data used to handle files included with "include" */
typedef struct {
  BoxSrcPos pos;
  UInt      msgcontext;
  UInt      num_errs, num_warns;
  YY_BUFFER_STATE
            buffer;
} TokIncludeData;

/** Structure defining the complete state of the scanner */
struct {
  int         is_initialised;
  BoxSrcName  *fnames;    /**< File names referred by BoxSrcPos objects */
  BoxSrcPos   pos;        /**< Current position in the source file */
  UInt        include_level,
              max_include_level;
  BoxArr      include_list;
  BoxHT       provided_features;
} state = {0};

/** Function used to count lines and columns (updating tok_src) */
static void My_Scan_Tok(void);

/** Function called in the #provide directive to determine whether the
 * feature has already been provided and the file should then be skipped.
 */
static int Tok_Provided(const char *feature, int length);

/** Variable defined by yacc to pass the location of the scanned token */
extern YYLTYPE yylloc;

%}

SPACES   [ \t]*
DIGIT    [0-9]
HEXDIGIT [0-9A-Fa-f]
NAME     [A-Za-z][A-Za-z0-9_]*
LNAME    [a-z][A-Za-z0-9_]*
UNAME    [A-Z][A-Za-z0-9_]*

%option noyywrap

%%

include BEGIN(include);

 /* Elimina gli spazi bianchi dopo la direttiva include */
<include>[ \t]*
 /* Cio' che segue include dopo gli eventuali spazi bianchi,
  * e' il nome del file: non sono consentiti commenti
  * o caratteri di continuazione riga sulla stessa riga di una include
  */
<include>["][^"\n]*["] {
  char *f = Str_Dup(yytext+1, yyleng-2);

  BEGIN(INITIAL);

  (void) Tok_Include_Begin(f);
  free(f);
}
 /* Tutto il resto da' errori! */
<include>. {
  BEGIN(INITIAL);
  return TOK_ERR;
}

 /* Se sto leggendo un file di include, quando arrivo alla sua fine
  * torno a leggere il precedente.
  */
<<EOF>> {if (Tok_Include_End()) {yyterminate();}}

 /* Un istruzione deve stare tutta su una riga.
  * Se questo diventa problematico e' possibile usare il carattere
  * di continuazione riga _
  */
"\n"    {My_Scan_Tok(); return TOK_NEWLINE;}

 /* Il carattere di continuazione riga mangia tutto ci che segue
  * fino alla nuova riga e annulla il carattere newline
  */
"_"{SPACES}"\n"       {My_Scan_Tok();}
"_"{SPACES}"//"[^\n]*"\n"  {My_Scan_Tok();}

 /* Scarta i commenti (i commenti iniziano col carattere '
  * e terminano alla fine della riga; per commenti su piu' righe
  * bisogna mettere un ' all'inizio di ogni riga di commento)
  */
"//"[^\n]*  {}
"#!"[^\n]*  {}

"#"{SPACES}"provide"{SPACES}["][^"\n]+["] {
  const char *feature = strchr(yytext, '"') + 1;
  int length = strchr(feature, '"') - feature - 1;
  if (Tok_Provided(feature, length)) {
    if (Tok_Include_End()) {yyterminate();}
  }
}

 /* Spaces are ignored */
{SPACES}    {My_Scan_Tok();}


"=>"  {My_Scan_Tok(); return TOK_TO;}
"->"  {My_Scan_Tok(); return TOK_MAPTO;}

 /* Assignment operators */
"+="  {My_Scan_Tok(); return TOK_APLUS;}
"-="  {My_Scan_Tok(); return TOK_AMINUS;}
"*="  {My_Scan_Tok(); return TOK_ATIMES;}
"%="  {My_Scan_Tok(); return TOK_AREM;}
"/="  {My_Scan_Tok(); return TOK_ADIV;}
"<<=" {My_Scan_Tok(); return TOK_ASHL;}
">>=" {My_Scan_Tok(); return TOK_ASHR;}
"&="  {My_Scan_Tok(); return TOK_ABAND;}
"^="  {My_Scan_Tok(); return TOK_ABXOR;}
"|="  {My_Scan_Tok(); return TOK_ABOR;}

 /* Increment/decrement operators */
"++"  {My_Scan_Tok(); return TOK_INC;}
"--"  {My_Scan_Tok(); return TOK_DEC;}

 /* Shift operators */
"<<"  {My_Scan_Tok(); return TOK_SHL;}
">>"  {My_Scan_Tok(); return TOK_SHR;}

 /* Comparison operators */
"=="  {My_Scan_Tok(); return TOK_EQ;}
"!="  {My_Scan_Tok(); return TOK_NE;}
"<="  {My_Scan_Tok(); return TOK_LE;}
">="  {My_Scan_Tok(); return TOK_GE;}

"&&"  {My_Scan_Tok(); return TOK_LAND;}
"||"  {My_Scan_Tok(); return TOK_LOR;}

 /* Other operators */
"**"  {My_Scan_Tok(); return TOK_POW;}

[$]+  { yylval.SelfLevel = yyleng; My_Scan_Tok(); return TOK_SELF;}

"@"   {My_Scan_Tok(); return TOK_AT;}
"@@"  {My_Scan_Tok(); return TOK_AT;} /* for compatibility with v 0.1 */
"@&"  {My_Scan_Tok(); return TOK_AT;} /* for compatibility with v 0.1 */

 /* Special tokens */
"(.[)" {yylval.TTag = BOXTYPE_CREATE;  My_Scan_Tok(); return TOK_TTAG;}
"(].)" {yylval.TTag = BOXTYPE_DESTROY; My_Scan_Tok(); return TOK_TTAG;}
"([)"  {yylval.TTag = BOXTYPE_BEGIN; My_Scan_Tok(); return TOK_TTAG;}
"(])"  {yylval.TTag = BOXTYPE_END; My_Scan_Tok(); return TOK_TTAG;}
"(;)"  {yylval.TTag = BOXTYPE_PAUSE; My_Scan_Tok(); return TOK_TTAG;}

 /* Number of type Char */
[']([^'\n]|\\')+['] {
  ASTConst c;
  if (Box_Reduce_Esc_Char(yytext+1, yyleng-2, (char *) & c.c) != BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_CHAR, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_CHAR, c);
  My_Scan_Tok();
  return TOK_CONSTANT;
 }

 /* for future use:
   [']    {}
   [']['] {}
  */

 /* Integer number */
{DIGIT}+ {
  ASTConst c;
  if (Str_ToInt(yytext, yyleng, & c.i) != BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
  My_Scan_Tok();
  return TOK_CONSTANT;
 }

 /* Integer number in hexadecimal notation */
[0][xX]{HEXDIGIT}+ {
  ASTConst c;
  if (Str_Hex_To_Int(yytext+2, yyleng-2, & c.i) != BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
  My_Scan_Tok();
  return TOK_CONSTANT;
 }

 /* Floating point number */
{DIGIT}+("."{DIGIT}+)?([eE][+-]?{DIGIT}+)? {
  ASTConst c;
  if (Str_ToReal(yytext, yyleng, & c.r) == BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_REAL, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_REAL, c);
  My_Scan_Tok();
  return TOK_CONSTANT;
 }

 /* String */
["]([^"\n]|\\\")*["] {
  size_t length;
  char *s = Box_Reduce_Esc_String(yytext + 1, yyleng - 2, & length);
  yylval.Node = ASTNodeString_New(s, length);
  BoxMem_Free(s);
  My_Scan_Tok();
  return TOK_STRING;
 }

 /* Variable name */
{LNAME} {
  yylval.String = BoxMem_Strndup(yytext, yyleng);
  My_Scan_Tok();
  return TOK_IDENTIFIER;
 }

 /* Type name */
{UNAME} {
  yylval.String = BoxMem_Strndup(yytext, yyleng);
  My_Scan_Tok();
  return TOK_TYPE_IDENT;
 }

 /* Everything which is not recognised is passed character by character to the
  * parser.
  */
. {My_Scan_Tok(); return yytext[0];}

%%

/* DESCRIZIONE: Prepara le funzioni di analisi lessicale del compilatore.
 *  Se f != NULL il compilatore partira' come se la prima istruzione
 *  del programma fosse una "include nomefile" dove nomefile e' la stringa
 *  a cui punta f.
 *  maxinc indica il numero massimo di file di include che possono essere
 *  aperti contemporaneamente.
 */
Task Tok_Init(FILE *main_file, const char *main_filename,
              const char *pre_filename) {
  assert(!state.is_initialised);

  state.is_initialised = 1;
  state.fnames = BoxSrcName_New();

  BoxSrcPos_Init(& state.pos, BoxSrcName_Add(state.fnames, main_filename));

  state.max_include_level = TOK_MAX_INCLUDE;

  /* Number of files opened through the include directive */
  state.include_level = 0;

  /* Creo una lista dove salvare i buffer, ogni qual volta
   * incontro una include
   */
  BoxArr_Init(& state.include_list, sizeof(TokIncludeData),
              TOK_TYPICAL_MAX_INCLUDE);

  BoxHT_Init_Default(& state.provided_features, 64);

  /* Read from stdin (which could have been redirected) */
  yyrestart(stdin);

  /* Se f == "nomefile" (e quindi f != NULL), eseguo una:
   * include "nomefile"
   */
  if (pre_filename == NULL)
    return Success;

  return Tok_Include_Begin(pre_filename);
}

/* DESCRIZIONE: Conclude l'analisi lessicale del compilatore.
 */
BoxSrcName *Tok_Finish(void) {
  assert(state.is_initialised);

  BoxHT_Finish(& state.provided_features);
  BoxArr_Finish(& state.include_list);
  state.is_initialised = 0;
  return state.fnames;
}

static void My_Scan_Tok(void) {
  size_t i;
  BoxSrcPosLine l, el;
  BoxSrcPosCol c, ec;

  el = l = state.pos.line;
  ec = c = state.pos.col;
  yylloc.first_line = l;
  yylloc.first_column = c;

  for(i = 0; i < yyleng; i++) {
    el = l; /* previous char */
    ec = c;

    if (yytext[i] == '\n') {
      c = 1;
      l += 1;

    } else {
      c += 1;
    }
  }

  state.pos.line = l;
  state.pos.col = c;

  yylloc.last_line = el;
  yylloc.last_column = ec;
}

/* DESCRIZIONE: Esegue materialmente la direttiva include,
 *  aprendo il file di nome f in lettura e deviando l'analisi lessicale
 *  su di esso. Bastera' poi eseguire tok_include_end() per ritornare al punto
 *  in cui la direttiva include aveva interrotto la lettura.
 */
Task Tok_Include_Begin(const char *f) {
  FILE *incfile;
  TokIncludeData cur;

  assert(state.is_initialised);

  if (state.include_level >= state.max_include_level) {
    MSG_ERROR("Cannot include \"%s\": too many files included!", f);
    return Failed;
  }

  incfile = Path_Open_Inc_File(f, "rt");

  if (incfile == NULL) {
    MSG_ERROR("\"%s\" <-- Cannot open the file!", f);
    return Failed;
  }

  cur.pos = state.pos;
  cur.msgcontext = 0; /*Msg_Context_Num(); TODO ??? */
  cur.num_errs = MSG_GT_ERRORS;
  cur.num_warns = MSG_NUM_WARNINGS;
  cur.buffer = YY_CURRENT_BUFFER;
  BoxArr_Push(& state.include_list, & cur);

  ++state.include_level;

  /* Update position */
  BoxSrcPos_Init(& state.pos, BoxSrcName_Add(state.fnames, f));

  yyin = incfile;
  yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));

  MSG_CONTEXT_BEGIN("Entering the included file \"%s\"", f);
  return Success;
}

/* DESCRIZIONE: Conclude la lettura di un file incluso con "include",
 *  restituendo 1 se non ci sono piu' file da leggere, 0 se bisogna riprendere
 *  la lettura dall'istruzione seguente la "include".
 */
UInt Tok_Include_End(void) {
  assert(state.is_initialised);

  if (state.include_level > 0) {
    TokIncludeData cur;
    UInt num_errs, num_warns;

    /* Cancella il buffer corrente */
    yy_delete_buffer( YY_CURRENT_BUFFER );
    /* Imposta il nuovo buffer all'ultimo inserito nello "stack" */
    cur = *((TokIncludeData *) BoxArr_Last_Item_Ptr(& state.include_list));
    state.pos = cur.pos;
    yy_switch_to_buffer(cur.buffer);
    /* Cancella l'ultimo elemento dello stack */
    BoxArr_Pop(& state.include_list, NULL);
    --state.include_level;
    /* Calcolo il numero di errori nel file incluso (+tutti i sotto-inclusi!) */
    num_errs = MSG_GT_ERRORS - cur.num_errs;
    num_warns = MSG_NUM_WARNINGS - cur.num_warns;
    MSG_ADVICE("Exiting from the included file. "
               "%U errors and %U warnings were found.",
               num_errs, num_warns );
    MSG_CONTEXT_END();
    return 0;

  } else
    return 1;
}

static int Tok_Provided(const char *feature, int length) {
  assert(state.is_initialised);

  BoxHTItem *item;
  if (BoxHT_Find(& state.provided_features,
                 (void *) feature, length, & item))
    return 1;
  BoxHT_Insert(& state.provided_features, (void *) feature, length);
  return 0;
}
