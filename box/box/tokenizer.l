/***************************************************************************
 *   Copyright (C) 2006-2012 by Matteo Franchin                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

%option reentrant
%option extra-type="BoxLex *"
%option noyywrap
%x include
 /* ^^^ Start condition used to extract the file name in include directives */
%x comment
 /* ^^^ Start condition used for parsing multi-line comments */

%{

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "types.h"
#include "defaults.h"
#include "mem.h"
#include "ast.h"
#include "messages.h"
#include "array.h"
#include "strutils.h"
#include "vm_private.h"
#include "tokenizer.h"
#include "parserh.h"
#include "parser.h" /* This is the file generated by yacc */
#include "builtins.h"
#include "fileutils.h"
#include "paths.h"
#include "hashtable.h"
#include "srcpos.h"
#include "paths.h"
#include "macro.h"

/* Use our message handler */
#define YY_FATAL_ERROR(msg) MSG_FATAL("%s", msg)

/** Data used to handle files included with "include" */
typedef struct {
  char      *script_dir;
  BoxSrcPos pos;
  UInt      msgcontext;
  UInt      num_errs, num_warns;

} MyIncludeData;

/** Function used to count lines and columns */
static void My_Scan_Tok(yyscan_t scanner);

/** Function used to notify entering a multi-line comment. */
static void My_Comment_Enter(BoxLex *bl, int is_macro);

/** Function used to notify exiting a multi-line comment. */
static int My_Comment_Leave(BoxLex *bl);

/** Read the char (useful only in macros). */
static void My_Comment_Read_Char(BoxLex *bl, const char *text, size_t len);

/** Process macros. */
static void My_Process_Macro(BoxLex *bl, BoxMacro *bm);

/** Shorthand macro for My_Scan_Tok. */
#define MY_SCAN_TOK() My_Scan_Tok(yyscanner)

/** Variable defined by yacc to pass the location of the scanned token */
extern YYLTYPE yylloc;

/** We want 'yylex' to be a static function, it is not meant to be called
 * directly. BoxLex_Next_Token should be used instead.
 */
#define YY_DECL static int yylex (yyscan_t yyscanner)

%}

SPACES   [ \t]*
DIGIT    [0-9]
HEXDIGIT [0-9A-Fa-f]
NAME     [A-Za-z][A-Za-z0-9_]*
LNAME    [a-z][A-Za-z0-9_]*
UNAME    [A-Z][A-Za-z0-9_]*
STRING   ["]([^"\n]|\\\")*["]

%%

[(][*][*]? {
  MY_SCAN_TOK();
  My_Comment_Enter(yyextra, (yyleng > 2));
  BEGIN(comment);
}

<comment>[*][)]  {
  MY_SCAN_TOK();
  if (My_Comment_Leave(yyextra))
   BEGIN(INITIAL);
}

<comment>[(][*][*]? {
  MY_SCAN_TOK();
  My_Comment_Enter(yyextra, (yyleng > 2));
}

<comment><<EOF>> {
  MY_SCAN_TOK();
  MSG_ERROR("File ended inside a comment.");
  BEGIN(INITIAL);
  yyterminate();
}

<comment>.|\n    {
  MY_SCAN_TOK();
  My_Comment_Read_Char(yyextra, yytext, yyleng);
}

include BEGIN(include);

 /* The following line removes white spaces after the include token */
<include>[ \t]*

 /* The file name follows ``include'': comments or the continuation character
  * are not allowed inside an include line.
  */
<include>{STRING} {
  char *f = Box_Normalize_Path(Str_Dup(yytext+1, yyleng-2));

  BEGIN(INITIAL);

  (void) BoxLex_Begin_Include(yyextra, f);
  BoxMem_Free(f);
}

 /* Whatever else gives errors */
<include>. {
  BEGIN(INITIAL);
  return TOK_ERR;
}

 /* At the end of file, if we are reading an included file, we return back to
  * the file which contained the include directive.
  */
<<EOF>> {if (BoxLex_End_Include(yyextra)) yyterminate();}

 /* One statement must typically fit one single line.
  * Alternatively, the line continuation character ``_'' or ``\'' can used
  * at the end of the line to continue the statement in the next line.
  */
"\n"    {MY_SCAN_TOK(); return TOK_NEWLINE;}

 /* Here are the rules to implement the line continuation. */
[_\\]{SPACES}"\n"            {MY_SCAN_TOK();}
[_\\]{SPACES}"//"[^\n]*"\n"  {MY_SCAN_TOK();}

 /* Discard comments. Comments start either with // or with #! */
"//"[^\n]*  {}
"#!"[^\n]*  {}

"#"{SPACES}"provide"{SPACES}["][^"\n]+["] {
  const char *feature = strchr(yytext, '"') + 1;
  int length = strchr(feature, '"') - feature - 1;
  if (BoxLex_Was_Provided(yyextra, feature, length)) {
    if (BoxLex_End_Include(yyextra))
      yyterminate();
  }
}

 /* Spaces are ignored */
{SPACES}    {MY_SCAN_TOK();}

"=>"  {MY_SCAN_TOK(); return TOK_TO;}
"->"  {MY_SCAN_TOK(); return TOK_MAPTO;}

 /* Assignment operators */
"+="  {MY_SCAN_TOK(); return TOK_APLUS;}
"-="  {MY_SCAN_TOK(); return TOK_AMINUS;}
"*="  {MY_SCAN_TOK(); return TOK_ATIMES;}
"%="  {MY_SCAN_TOK(); return TOK_AREM;}
"/="  {MY_SCAN_TOK(); return TOK_ADIV;}
"<<=" {MY_SCAN_TOK(); return TOK_ASHL;}
">>=" {MY_SCAN_TOK(); return TOK_ASHR;}
"&="  {MY_SCAN_TOK(); return TOK_ABAND;}
"^="  {MY_SCAN_TOK(); return TOK_ABXOR;}
"|="  {MY_SCAN_TOK(); return TOK_ABOR;}

 /* Increment/decrement operators */
"++"  {MY_SCAN_TOK(); return TOK_INC;}
"--"  {MY_SCAN_TOK(); return TOK_DEC;}

 /* Shift operators */
"<<"  {MY_SCAN_TOK(); return TOK_SHL;}
">>"  {MY_SCAN_TOK(); return TOK_SHR;}

 /* Comparison operators */
"=="  {MY_SCAN_TOK(); return TOK_EQ;}
"!="  {MY_SCAN_TOK(); return TOK_NE;}
"<="  {MY_SCAN_TOK(); return TOK_LE;}
">="  {MY_SCAN_TOK(); return TOK_GE;}

"&&"  {MY_SCAN_TOK(); return TOK_LAND;}
"||"  {MY_SCAN_TOK(); return TOK_LOR;}

 /* Other operators */
"**"  {MY_SCAN_TOK(); return TOK_POW;}

[$]+  { yylval.SelfLevel = yyleng; MY_SCAN_TOK(); return TOK_SELF;}

 /* Combination symbols */
"@"   {yylval.Combine = BOXCOMBTYPE_AT; MY_SCAN_TOK(); return TOK_COMBINE;}
"(=)" {yylval.Combine = BOXCOMBTYPE_COPY; MY_SCAN_TOK(); return TOK_COMBINE;}
 /* for compatibility with v 0.1 */
"@@"  {yylval.Combine = BOXCOMBTYPE_AT; MY_SCAN_TOK(); return TOK_COMBINE;}
"@&"  {yylval.Combine = BOXCOMBTYPE_AT; MY_SCAN_TOK(); return TOK_COMBINE;}

 /* Special tokens */
"(.[)" {yylval.TTag = BOXTYPE_CREATE;  MY_SCAN_TOK(); return TOK_TTAG;}
"(].)" {yylval.TTag = BOXTYPE_DESTROY; MY_SCAN_TOK(); return TOK_TTAG;}
"([)"  {yylval.TTag = BOXTYPE_BEGIN; MY_SCAN_TOK(); return TOK_TTAG;}
"(])"  {yylval.TTag = BOXTYPE_END; MY_SCAN_TOK(); return TOK_TTAG;}
"(;)"  {yylval.TTag = BOXTYPE_PAUSE; MY_SCAN_TOK(); return TOK_TTAG;}

 /* Number of type Char */
[']([^'\n]|\\')+['] {
  ASTConst c;
  if (Box_Reduce_Esc_Char(yytext+1, yyleng-2, (char *) & c.c) != BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_CHAR, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_CHAR, c);
  MY_SCAN_TOK();
  return TOK_CONSTANT;
 }

 /* for future use:
   [']    {}
   [']['] {}
  */

 /* Integer number */
{DIGIT}+ {
  ASTConst c;
  if (Str_ToInt(yytext, yyleng, & c.i) != BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
  MY_SCAN_TOK();
  return TOK_CONSTANT;
 }

 /* Integer number in hexadecimal notation */
[0][xX]{HEXDIGIT}+ {
  ASTConst c;
  if (Str_Hex_To_Int(yytext+2, yyleng-2, & c.i) != BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
  MY_SCAN_TOK();
  return TOK_CONSTANT;
 }

 /* Floating point number */
{DIGIT}+("."{DIGIT}+)?([eE][+-]?{DIGIT}+)? {
  ASTConst c;
  if (Str_ToReal(yytext, yyleng, & c.r) == BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_REAL, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_REAL, c);
  MY_SCAN_TOK();
  return TOK_CONSTANT;
 }

 /* String */
{STRING} {
  size_t length;
  char *s = Box_Reduce_Esc_String(yytext + 1, yyleng - 2, & length);
  yylval.Node = ASTNodeString_New(s, length);
  BoxMem_Free(s);
  MY_SCAN_TOK();
  return TOK_STRING;
 }

Else {
  yylval.String = BoxMem_Strndup(yytext, yyleng);
  MY_SCAN_TOK();
  return TOK_KEYWORD;
}

 /* Variable name */
{LNAME} {
  yylval.String = BoxMem_Strndup(yytext, yyleng);
  MY_SCAN_TOK();
  return TOK_IDENTIFIER;
 }

 /* Type name */
{UNAME} {
  yylval.String = BoxMem_Strndup(yytext, yyleng);
  MY_SCAN_TOK();
  return TOK_TYPE_IDENT;
 }

 /* Everything which is not recognised is passed character by character to the
  * parser.
  */
. {MY_SCAN_TOK(); return yytext[0];}

%%

struct _struct_BoxLex {
  BoxPaths    *paths;            /**< Paths used to search for files */
  yyscan_t    scanner;           /**< The Lex scanner */
  BoxSrcName  *fnames;           /**< File names referred by BoxSrcPos
                                      objects */
  BoxSrcPos   pos;               /**< Current position in the source file */
  size_t      max_include_level, /**< Max number of includeable files */
              comment_level;     /**< Multi-comment level of inclusion */
  BoxArr      include_list;      /**< Stack of saved data for include files */
  BoxHT       provided_features; /**< Hashtb. to remember provided features */
  int         parsing_macro;     /**< Whether we are parsing a comment macro */
  BoxArr      macro_content;     /**< Content of currently parsed macro */
};

BoxLex *BoxLex_Create(BoxPaths *paths) {
  BoxLex *bl = BoxMem_Safe_Alloc(sizeof(BoxLex));
  yylex_init(& bl->scanner);
  yyset_extra(bl, bl->scanner);

  bl->comment_level = 0;
  bl->paths = paths;
  bl->fnames = BoxSrcName_New();
  BoxSrcPos_Init(& bl->pos, "<stdin>");

  bl->max_include_level = TOK_MAX_INCLUDE;
  BoxArr_Init(& bl->include_list, sizeof(MyIncludeData),
              TOK_TYPICAL_MAX_INCLUDE);

  BoxHT_Init_Default(& bl->provided_features, 64);

  bl->parsing_macro = 0;
  BoxArr_Init(& bl->macro_content, 1, 64);
  return bl;
}

BoxSrcName *BoxLex_Destroy(BoxLex *bl) {
  BoxSrcName *filenames = bl->fnames;
  yylex_destroy(bl->scanner);
  BoxHT_Finish(& bl->provided_features);
  BoxArr_Finish(& bl->include_list);
  BoxArr_Finish(& bl->macro_content);
  BoxMem_Free(bl);
  return filenames;
}

int BoxLex_Next_Token(BoxLex *bl) {
  if (BoxArr_Num_Items(& bl->include_list) > 0)
    return yylex(bl->scanner);

  else
    MSG_FATAL("BoxLex_Next_Token: the source file has not been specified. "
              "Use BoxLex_Begin_Include to set it.");
}

BoxTask BoxLex_Begin_Include_FILE(BoxLex *bl, FILE *f, const char *fn) {
  size_t include_level = BoxArr_Num_Items(& bl->include_list);

  if (include_level >= bl->max_include_level) {
    MSG_ERROR("Cannot include \"%s\": too many files included!", fn);
    return BOXTASK_ERROR;

  } else {
    YY_BUFFER_STATE buffer;
    MyIncludeData *cur = BoxArr_Push(& bl->include_list, NULL);
    cur->pos = bl->pos;
    cur->script_dir = NULL;
    cur->msgcontext = 0; /*Msg_Context_Num(); TODO ??? */
    cur->num_errs = MSG_GT_ERRORS;
    cur->num_warns = MSG_NUM_WARNINGS;

    buffer = yy_create_buffer(f, YY_BUF_SIZE, bl->scanner);
    assert(buffer != NULL);    
    yypush_buffer_state(buffer, bl->scanner);
    BoxSrcPos_Init(& bl->pos, BoxSrcName_Add(bl->fnames, fn));

    MSG_CONTEXT_BEGIN("Entering the included file \"%s\"", fn);
    return BOXTASK_OK;
  }
}

const char *BoxLex_Get_Script_Dir(BoxLex *bl) {
  size_t num_included_files = BoxArr_Num_Items(& bl->include_list);
  if (num_included_files > 0) {
    MyIncludeData *cur = BoxArr_Last_Item_Ptr(& bl->include_list);
    return cur->script_dir;

  } else
    return NULL;
}

BoxTask BoxLex_Begin_Include(BoxLex *bl, const char *fn) {
  const char *script_dir = BoxLex_Get_Script_Dir(bl);
  char *full_path = BoxPaths_Find_Inc_File(bl->paths, script_dir, fn);
  FILE *f = NULL;

  if (full_path == NULL) {
    MSG_ERROR("\"%s\" <-- Cannot find the file!", fn);
    return BOXTASK_ERROR;
  }

  f = fopen(full_path, "rt");
  if (f == NULL) {
    MSG_ERROR("\"%s\" <-- Cannot open the file!", fn);
    return BOXTASK_ERROR;

  } else {
    BoxTask t = BoxLex_Begin_Include_FILE(bl, f, fn);
    if (t == BOXTASK_OK) {
      MyIncludeData *cur = BoxArr_Last_Item_Ptr(& bl->include_list);
      Box_Split_Path(& cur->script_dir, NULL, full_path);
      return BOXTASK_OK;

    } else
      return t;
  }
}

int BoxLex_End_Include(BoxLex *bl) {
  size_t include_level = BoxArr_Num_Items(& bl->include_list);
  if (include_level > 0) {
    size_t num_errs, num_warns;
    MyIncludeData cur;

    /* Retrieve the last include data block and remove it from the stack */
    BoxArr_Pop(& bl->include_list, & cur);

    /* Return to the previous buffer and restore the previous position */
    yypop_buffer_state(bl->scanner);
    bl->pos = cur.pos;

    BoxMem_Free(cur.script_dir);

    /* Compute the number of errors in the included file */
    num_errs = MSG_GT_ERRORS - cur.num_errs;
    num_warns = MSG_NUM_WARNINGS - cur.num_warns;
    MSG_ADVICE("Exiting from the included file. "
               "%U errors and %U warnings were found.",
               num_errs, num_warns );
    MSG_CONTEXT_END();
    return (include_level == 1);

  } else
    return 1;
}

int BoxLex_Was_Provided(BoxLex *bl, const char *feature, int length) {
  BoxHTItem *item;
  if (BoxHT_Find(& bl->provided_features, (void *) feature, length, & item))
    return 1;
  BoxHT_Insert(& bl->provided_features, (void *) feature, length);
  return 0;
}

static void My_Scan_Tok(yyscan_t scanner) {
  size_t i, tok_length = yyget_leng(scanner);
  const char *tok_text = yyget_text(scanner);
  BoxSrcPosLine l, el;
  BoxSrcPosCol c, ec;
  BoxLex *box_lexer = yyget_extra(scanner);

  el = l = box_lexer->pos.line;
  ec = c = box_lexer->pos.col;
  yylloc.begin = box_lexer->pos;

  for(i = 0; i < tok_length; i++) {
    el = l; /* previous char */
    ec = c;

    if (tok_text[i] == '\n') {
      c = 1;
      l += 1;

    } else
      c += 1;
  }

  box_lexer->pos.line = l;
  box_lexer->pos.col = c;

  yylloc.end.line = el;
  yylloc.end.col = ec;
  yylloc.end.file_name = box_lexer->pos.file_name;
}

static void My_Comment_Enter(BoxLex *bl, int is_macro) {
  ++bl->comment_level;
  assert(bl->comment_level != 0);

  bl->parsing_macro = is_macro;
  BoxArr_Empty(& bl->macro_content);
}

static int My_Comment_Leave(BoxLex *bl) {
  assert(bl->comment_level > 0);
  --bl->comment_level;

  /* Parse the macro, if necessary */
  if (bl->parsing_macro) {
    BoxMacro bm;
    char line_term = '\0';
    BoxArr_Push(& bl->macro_content, & line_term);

    BoxMacro_Init(& bm, (char *) BoxArr_First_Item_Ptr(& bl->macro_content));
    BoxMacro_Parse(& bm);

    My_Process_Macro(bl, & bm);
    BoxMacro_Finish(& bm);
  }

  bl->parsing_macro = 0;
  return (bl->comment_level == 0);
}

static void My_Comment_Read_Char(BoxLex *bl, const char *text, size_t len) {
  if (bl->parsing_macro)
    BoxArr_MPush(& bl->macro_content, text, len);
}

/** Parse an integer from the string 'text' and - if successful - put it into
 * '*arg' and return 1. Return 0 in case of errors.
 */
static int My_Parse_Int_Arg(const char *text, long int *arg) {
  errno = 0;
  char *endptr;
  long int retval = strtol(text, & endptr, 10);
  if (errno == 0 && endptr != text && *endptr == '\0') {
    if (arg != NULL)
      *arg = retval;
    return 1;

  } else
    return 0;
}

/** Check that 'text' is a string of the type '"content"' and - if this is the
 * case - set '*arg' to the first character after " and substitutes the closing
 * " with a NUL (so that '*arg' is actually the content of the string).
 * 'text' is modified by a call to this function.
 */
static int My_Parse_Str_Arg(char *text, char **arg) {
  size_t len = strlen(text);
  if (len > 2 && text[0] == '"' && text[len - 1] == '"') {
    text[len - 1] = '\0';
    *arg = & text[1];
    return 1;

  } else
    return 0;
}

/* Process macros embedded in comments like (**macro: args*) */
static void My_Process_Macro(BoxLex *bl, BoxMacro *bm) {
  const char *name = BoxMacro_Get_Name(bm);
  size_t num_args = BoxMacro_Get_Num_Args(bm);

  if (name && strcmp(name, "line") == 0) {
    long int arg1;
    if (num_args >= 1 && My_Parse_Int_Arg(BoxMacro_Get_Arg(bm, 0), & arg1)) {
      long int arg2;
      BoxSrcPos_Set_Line(& bl->pos, (arg1 > 0) ? arg1 : 0);

      if (num_args >= 2 && My_Parse_Int_Arg(BoxMacro_Get_Arg(bm, 1), & arg2)) {
        char *arg3;

        BoxSrcPos_Set_Col(& bl->pos, (arg2 > 0) ? arg2 : 0);

        if (My_Parse_Str_Arg(BoxMacro_Get_Arg(bm, 2), & arg3))
          BoxSrcPos_Set_File_Name(& bl->pos, BoxSrcName_Add(bl->fnames, arg3));
      }
    }
  }
}
