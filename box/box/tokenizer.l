/***************************************************************************
 *   Copyright (C) 2006 by Matteo Franchin                                 *
 *   fnch@libero.it                                                        *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

%option reentrant
%option extra-type="BoxLex *"
%option noyywrap
%x include
 /* ^^^ Start condition used to extract the file name in include directives */

%{

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "types.h"
#include "defaults.h"
#include "mem.h"
#include "ast.h"
#include "messages.h"
#include "array.h"
#include "strutils.h"
#include "virtmach.h"
#include "tokenizer.h"
#include "parserh.h"
#include "parser.h" /* This is the file generated by yacc */
#include "builtins.h"
#include "fileutils.h"
#include "paths.h"
#include "hashtable.h"
#include "srcpos.h"

/* Use our message handler */
#define YY_FATAL_ERROR(msg) MSG_FATAL("%s", msg)

/** Data used to handle files included with "include" */
typedef struct {
  BoxSrcPos pos;
  UInt      msgcontext;
  UInt      num_errs, num_warns;
} MyIncludeData;

/** Function used to count lines and columns (updating tok_src) */
static void My_Scan_Tok(yyscan_t scanner);

/** Shorthand macro for My_Scan_Tok. */
#define MY_SCAN_TOK() My_Scan_Tok(yyscanner)

/** Variable defined by yacc to pass the location of the scanned token */
extern YYLTYPE yylloc;

/** We want 'yylex' to be a static function, it is not meant to be called
 * directly. BoxLex_Next_Token should be used instead.
 */
#define YY_DECL static int yylex (yyscan_t yyscanner)

%}

SPACES   [ \t]*
DIGIT    [0-9]
HEXDIGIT [0-9A-Fa-f]
NAME     [A-Za-z][A-Za-z0-9_]*
LNAME    [a-z][A-Za-z0-9_]*
UNAME    [A-Z][A-Za-z0-9_]*

%%

include BEGIN(include);

 /* Elimina gli spazi bianchi dopo la direttiva include */
<include>[ \t]*
 /* Cio' che segue include dopo gli eventuali spazi bianchi,
  * e' il nome del file: non sono consentiti commenti
  * o caratteri di continuazione riga sulla stessa riga di una include
  */
<include>["][^"\n]*["] {
  char *f = Str_Dup(yytext+1, yyleng-2);

  BEGIN(INITIAL);

  (void) BoxLex_Begin_Include(yyextra, f);
  BoxMem_Free(f);
}
 /* Tutto il resto da' errori! */
<include>. {
  BEGIN(INITIAL);
  return TOK_ERR;
}

 /* Se sto leggendo un file di include, quando arrivo alla sua fine
  * torno a leggere il precedente.
  */
<<EOF>> {if (BoxLex_End_Include(yyextra)) yyterminate();}

 /* Un istruzione deve stare tutta su una riga.
  * Se questo diventa problematico e' possibile usare il carattere
  * di continuazione riga _
  */
"\n"    {MY_SCAN_TOK(); return TOK_NEWLINE;}

 /* Il carattere di continuazione riga mangia tutto ci che segue
  * fino alla nuova riga e annulla il carattere newline
  */
"_"{SPACES}"\n"            {MY_SCAN_TOK();}
"_"{SPACES}"//"[^\n]*"\n"  {MY_SCAN_TOK();}

 /* Discard comments. Comments start either with // or with #! */
"//"[^\n]*  {}
"#!"[^\n]*  {}

"#"{SPACES}"provide"{SPACES}["][^"\n]+["] {
  const char *feature = strchr(yytext, '"') + 1;
  int length = strchr(feature, '"') - feature - 1;
  if (BoxLex_Was_Provided(yyextra, feature, length)) {
    if (BoxLex_End_Include(yyextra))
      yyterminate();
  }
}

 /* Spaces are ignored */
{SPACES}    {MY_SCAN_TOK();}


"=>"  {MY_SCAN_TOK(); return TOK_TO;}
"->"  {MY_SCAN_TOK(); return TOK_MAPTO;}

 /* Assignment operators */
"+="  {MY_SCAN_TOK(); return TOK_APLUS;}
"-="  {MY_SCAN_TOK(); return TOK_AMINUS;}
"*="  {MY_SCAN_TOK(); return TOK_ATIMES;}
"%="  {MY_SCAN_TOK(); return TOK_AREM;}
"/="  {MY_SCAN_TOK(); return TOK_ADIV;}
"<<=" {MY_SCAN_TOK(); return TOK_ASHL;}
">>=" {MY_SCAN_TOK(); return TOK_ASHR;}
"&="  {MY_SCAN_TOK(); return TOK_ABAND;}
"^="  {MY_SCAN_TOK(); return TOK_ABXOR;}
"|="  {MY_SCAN_TOK(); return TOK_ABOR;}

 /* Increment/decrement operators */
"++"  {MY_SCAN_TOK(); return TOK_INC;}
"--"  {MY_SCAN_TOK(); return TOK_DEC;}

 /* Shift operators */
"<<"  {MY_SCAN_TOK(); return TOK_SHL;}
">>"  {MY_SCAN_TOK(); return TOK_SHR;}

 /* Comparison operators */
"=="  {MY_SCAN_TOK(); return TOK_EQ;}
"!="  {MY_SCAN_TOK(); return TOK_NE;}
"<="  {MY_SCAN_TOK(); return TOK_LE;}
">="  {MY_SCAN_TOK(); return TOK_GE;}

"&&"  {MY_SCAN_TOK(); return TOK_LAND;}
"||"  {MY_SCAN_TOK(); return TOK_LOR;}

 /* Other operators */
"**"  {MY_SCAN_TOK(); return TOK_POW;}

[$]+  { yylval.SelfLevel = yyleng; MY_SCAN_TOK(); return TOK_SELF;}

 /* Combination symbols */
"@"   {yylval.Combine = BOXCOMB_CHILDOF; MY_SCAN_TOK(); return TOK_COMBINE;}
"(=)" {yylval.Combine = BOXCOMB_COPYTO; MY_SCAN_TOK(); return TOK_COMBINE;}
 /* for compatibility with v 0.1 */
"@@"  {yylval.Combine = BOXCOMB_CHILDOF; MY_SCAN_TOK(); return TOK_COMBINE;}
"@&"  {yylval.Combine = BOXCOMB_CHILDOF; MY_SCAN_TOK(); return TOK_COMBINE;}

 /* Special tokens */
"(.[)" {yylval.TTag = BOXTYPE_CREATE;  MY_SCAN_TOK(); return TOK_TTAG;}
"(].)" {yylval.TTag = BOXTYPE_DESTROY; MY_SCAN_TOK(); return TOK_TTAG;}
"([)"  {yylval.TTag = BOXTYPE_BEGIN; MY_SCAN_TOK(); return TOK_TTAG;}
"(])"  {yylval.TTag = BOXTYPE_END; MY_SCAN_TOK(); return TOK_TTAG;}
"(;)"  {yylval.TTag = BOXTYPE_PAUSE; MY_SCAN_TOK(); return TOK_TTAG;}

 /* Number of type Char */
[']([^'\n]|\\')+['] {
  ASTConst c;
  if (Box_Reduce_Esc_Char(yytext+1, yyleng-2, (char *) & c.c) != BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_CHAR, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_CHAR, c);
  MY_SCAN_TOK();
  return TOK_CONSTANT;
 }

 /* for future use:
   [']    {}
   [']['] {}
  */

 /* Integer number */
{DIGIT}+ {
  ASTConst c;
  if (Str_ToInt(yytext, yyleng, & c.i) != BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
  MY_SCAN_TOK();
  return TOK_CONSTANT;
 }

 /* Integer number in hexadecimal notation */
[0][xX]{HEXDIGIT}+ {
  ASTConst c;
  if (Str_Hex_To_Int(yytext+2, yyleng-2, & c.i) != BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_INT, c);
  MY_SCAN_TOK();
  return TOK_CONSTANT;
 }

 /* Floating point number */
{DIGIT}+("."{DIGIT}+)?([eE][+-]?{DIGIT}+)? {
  ASTConst c;
  if (Str_ToReal(yytext, yyleng, & c.r) == BOXTASK_OK) {
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_REAL, c);
    ASTNode_Set_Error(yylval.Node);
  } else
    yylval.Node = ASTNodeConst_New(ASTCONSTTYPE_REAL, c);
  MY_SCAN_TOK();
  return TOK_CONSTANT;
 }

 /* String */
["]([^"\n]|\\\")*["] {
  size_t length;
  char *s = Box_Reduce_Esc_String(yytext + 1, yyleng - 2, & length);
  yylval.Node = ASTNodeString_New(s, length);
  BoxMem_Free(s);
  MY_SCAN_TOK();
  return TOK_STRING;
 }

 /* Variable name */
{LNAME} {
  yylval.String = BoxMem_Strndup(yytext, yyleng);
  MY_SCAN_TOK();
  return TOK_IDENTIFIER;
 }

 /* Type name */
{UNAME} {
  yylval.String = BoxMem_Strndup(yytext, yyleng);
  MY_SCAN_TOK();
  return TOK_TYPE_IDENT;
 }

 /* Everything which is not recognised is passed character by character to the
  * parser.
  */
. {MY_SCAN_TOK(); return yytext[0];}

%%

struct _struct_BoxLex {
  yyscan_t    scanner;           /**< The Lex scanner */

  BoxSrcName  *fnames;           /**< File names referred by BoxSrcPos
                                      objects */
  BoxSrcPos   pos;               /**< Current position in the source file */
  size_t      max_include_level; /**< Max number of includeable files */
  BoxArr      include_list;      /**< Stack of saved data for include files */
  BoxHT       provided_features; /**< Hashtb. to remember provided features */
};

BoxLex *BoxLex_Create(void) {
  BoxLex *bl = BoxMem_Safe_Alloc(sizeof(BoxLex));
  yylex_init(& bl->scanner);
  yyset_extra(bl, bl->scanner);

  bl->fnames = BoxSrcName_New();
  BoxSrcPos_Init(& bl->pos, "<stdin>");

  bl->max_include_level = TOK_MAX_INCLUDE;
  BoxArr_Init(& bl->include_list, sizeof(MyIncludeData),
              TOK_TYPICAL_MAX_INCLUDE);

  BoxHT_Init_Default(& bl->provided_features, 64);
  return bl;
}

BoxSrcName *BoxLex_Destroy(BoxLex *bl) {
  BoxSrcName *filenames = bl->fnames;
  yylex_destroy(bl->scanner);
  BoxHT_Finish(& bl->provided_features);
  BoxArr_Finish(& bl->include_list);
  BoxMem_Free(bl);
  return filenames;
}

int BoxLex_Next_Token(BoxLex *bl) {
  if (BoxArr_Num_Items(& bl->include_list) > 0)
    return yylex(bl->scanner);

  else
    MSG_FATAL("BoxLex_Next_Token: the source file has not been specified. "
              "Use BoxLex_Begin_Include to set it.");
}

BoxTask BoxLex_Begin_Include_FILE(BoxLex *bl, FILE *f, const char *fn) {
  size_t include_level = BoxArr_Num_Items(& bl->include_list);

  if (include_level >= bl->max_include_level) {
    MSG_ERROR("Cannot include \"%s\": too many files included!", fn);
    return BOXTASK_ERROR;

  } else {
    YY_BUFFER_STATE buffer;
    MyIncludeData cur;  
    cur.pos = bl->pos;
    cur.msgcontext = 0; /*Msg_Context_Num(); TODO ??? */
    cur.num_errs = MSG_GT_ERRORS;
    cur.num_warns = MSG_NUM_WARNINGS;
    BoxArr_Push(& bl->include_list, & cur);

    buffer = yy_create_buffer(f, YY_BUF_SIZE, bl->scanner);
    assert(buffer != NULL);    
    yypush_buffer_state(buffer, bl->scanner);
    BoxSrcPos_Init(& bl->pos, BoxSrcName_Add(bl->fnames, fn));

    MSG_CONTEXT_BEGIN("Entering the included file \"%s\"", fn);
    return BOXTASK_OK;
  }
}

BoxTask BoxLex_Begin_Include(BoxLex *bl, const char *fn) {
  FILE *f = Path_Open_Inc_File(fn, "rt");
  if (f == NULL) {
    MSG_ERROR("\"%s\" <-- Cannot open the file!", fn);
    return BOXTASK_ERROR;
  }

  return BoxLex_Begin_Include_FILE(bl, f, fn);
}

int BoxLex_End_Include(BoxLex *bl) {
  size_t include_level = BoxArr_Num_Items(& bl->include_list);
  if (include_level > 0) {
    size_t num_errs, num_warns;
    MyIncludeData cur;

    /* Retrieve the last include data block and remove it from the stack */
    BoxArr_Pop(& bl->include_list, & cur);

    /* Return to the previous buffer and restore the previous position */
    yypop_buffer_state(bl->scanner);
    bl->pos = cur.pos;

    /* Compute the number of errors in the included file */
    num_errs = MSG_GT_ERRORS - cur.num_errs;
    num_warns = MSG_NUM_WARNINGS - cur.num_warns;
    MSG_ADVICE("Exiting from the included file. "
               "%U errors and %U warnings were found.",
               num_errs, num_warns );
    MSG_CONTEXT_END();
    return (include_level == 1);

  } else
    return 1;
}

int BoxLex_Was_Provided(BoxLex *bl, const char *feature, int length) {
  BoxHTItem *item;
  if (BoxHT_Find(& bl->provided_features, (void *) feature, length, & item))
    return 1;
  BoxHT_Insert(& bl->provided_features, (void *) feature, length);
  return 0;
}

static void My_Scan_Tok(yyscan_t scanner) {
  size_t i, tok_length = yyget_leng(scanner);
  const char *tok_text = yyget_text(scanner);
  BoxSrcPosLine l, el;
  BoxSrcPosCol c, ec;
  BoxLex *box_lexer = yyget_extra(scanner);

  el = l = box_lexer->pos.line;
  ec = c = box_lexer->pos.col;
  yylloc.begin = box_lexer->pos;

  for(i = 0; i < tok_length; i++) {
    el = l; /* previous char */
    ec = c;

    if (tok_text[i] == '\n') {
      c = 1;
      l += 1;

    } else
      c += 1;
  }

  box_lexer->pos.line = l;
  box_lexer->pos.col = c;

  yylloc.end.line = el;
  yylloc.end.col = ec;
  yylloc.end.file_name = box_lexer->pos.file_name;
}
