/***************************************************************************
 *   Copyright (C) 2006-2013 by Matteo Franchin                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

%option reentrant
%option extra-type="BoxParser *"
%option noyywrap nounput noinput
%x include
 /* ^^^ Start condition used to extract the file name in include directives */
%x comment
 /* ^^^ Start condition used for parsing multi-line comments */

%{

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "types.h"
#include "defaults.h"
#include "mem.h"
#include "messages.h"
#include "strutils.h"
#include "vm_priv.h"
#include "parser.h"
#include "builtins.h"
#include "fileutils.h"
#include "srcpos.h"
#include "macro.h"

/* The file below is generated by yacc. */
#include "yparser.h"

#include <box/parser.h>
#include <box/ast_priv.h>

#include <box/parser_priv.h>

/* Add our own position tracking code. We here assume the token does not
 * contain newline characters. All exceptions have need to be corrected with
 * a call to My_Fix_Pos().
 */
#define YY_USER_ACTION \
  yyextra->src.begin = yyextra->src.end; \
  yyextra->src.end += yyleng; \
  yyextra->pos.col += yyleng;

/* Function used to update the location counters (line, column, etc.) */
static void My_Fix_Pos(yyscan_t scanner);

/* Shorthand for My_Fix_Pos(). */
#define MY_FIX_POS \
  My_Fix_Pos(yyscanner)

#define MY_NODE(nodeType, args...) \
  BoxAST_Create_##nodeType(yyextra->ast, & yyextra->src, args)

/* Generic error reporting. */
#define MY_ERR(args...) \
  BoxParser_Log_Err(yyextra, args)

/* Token-related error reporting. */
#define MY_TOK_ERR(args...) \
  BoxParser_Log_Tok_Err(yyextra, args)

/* Use our message handler */
#define YY_FATAL_ERROR(msg) MSG_FATAL("%s", msg)

/** Function used to notify entering a multi-line comment. */
static void My_Comment_Enter(BoxParser *bl, int is_macro);

/** Function used to notify exiting a multi-line comment. */
static int My_Comment_Leave(BoxParser *bl);

/** Read the char (useful only in macros). */
static void My_Comment_Read_Char(BoxParser *bl, const char *text, size_t len);

/** Process macros. */
static void My_Process_Macro(BoxParser *bl, BoxMacro *bm);

/** Variable defined by yacc to pass the location of the scanned token */
extern YYLTYPE yylloc;

/** We want 'yylex' to be a static function, it is not meant to be called
 * directly. BoxParser_Get_Next_Token should be used instead.
 */
#define YY_DECL static int yylex (yyscan_t yyscanner)


%}

SPACES   [ \t]*
DIGIT    [0-9]
HEXDIGIT [0-9A-Fa-f]
NAME     [A-Za-z][A-Za-z0-9_]*
LNAME    [a-z][A-Za-z0-9_]*
UNAME    [A-Z][A-Za-z0-9_]*
STRING   ["]([^"\n]|\\\")*["]

%%

[(][*][*]? {
  My_Comment_Enter(yyextra, (yyleng > 2));
  BEGIN(comment);
}

<comment>[*][)]  {
  if (My_Comment_Leave(yyextra))
   BEGIN(INITIAL);
}

<comment>[(][*][*]? {
  My_Comment_Enter(yyextra, (yyleng > 2));
}

<comment><<EOF>> {
  MY_ERR("File ended inside a comment.");
  BEGIN(INITIAL);
  yyterminate();
}

<comment>.|\n    {
  MY_FIX_POS;
  My_Comment_Read_Char(yyextra, yytext, yyleng);
}

include BEGIN(include);

 /* The following line removes white spaces after the include token */
<include>[ \t]*

 /* The file name follows ``include'': comments or the continuation character
  * are not allowed inside an include line.
  */
<include>{STRING} {
  char *f = Box_Normalize_Path(Box_Mem_Strndup(yytext + 1, yyleng - 2));

  BEGIN(INITIAL);

  (void) BoxParser_Begin_Include(yyextra, f);
  Box_Mem_Free(f);
}

 /* Whatever else gives errors */
<include>. {
  BEGIN(INITIAL);
  return TOK_ERR;
}

 /* At the end of file, if we are reading an included file, we return back to
  * the file which contained the include directive.
  */
<<EOF>> {if (BoxParser_End_Include(yyextra)) yyterminate();}

 /* One statement must typically fit one single line.
  * Alternatively, the line continuation character ``_'' or ``\'' can used
  * at the end of the line to continue the statement in the next line.
  */
"\n"    {MY_FIX_POS; return TOK_NEWLINE;}

 /* Here are the rules to implement the line continuation. */
[_\\]{SPACES}"\n"            {MY_FIX_POS;}
[_\\]{SPACES}"//"[^\n]*"\n"  {MY_FIX_POS;}

 /* Discard comments. Comments start either with // or with #! */
"//"[^\n]*  {}
"#!"[^\n]*  {}

"#"{SPACES}"provide"{SPACES}["][^"\n]+["] {
  const char *feature = strchr(yytext, '"') + 1;
  int length = strchr(feature, '"') - feature - 1;
  if (BoxParser_Was_Provided(yyextra, feature, length)) {
    if (BoxParser_End_Include(yyextra))
      yyterminate();
  }
}

 /* Spaces are ignored */
{SPACES}    {}

":="  {return TOK_DEFINE;}
"=>"  {return TOK_TO;}
"->"  {return TOK_MAPTO;}

 /* Assignment operators */
"+="  {return TOK_APLUS;}
"-="  {return TOK_AMINUS;}
"*="  {return TOK_ATIMES;}
"%="  {return TOK_AREM;}
"/="  {return TOK_ADIV;}
"<<=" {return TOK_ASHL;}
">>=" {return TOK_ASHR;}
"&="  {return TOK_ABAND;}
"^="  {return TOK_ABXOR;}
"|="  {return TOK_ABOR;}

 /* Increment/decrement operators */
"++"  {return TOK_INC;}
"--"  {return TOK_DEC;}

 /* Shift operators */
"<<"  {return TOK_SHL;}
">>"  {return TOK_SHR;}

 /* Comparison operators */
"=="  {return TOK_EQ;}
"!="  {return TOK_NE;}
"<="  {return TOK_LE;}
">="  {return TOK_GE;}

"&&"  {return TOK_LAND;}
"||"  {return TOK_LOR;}

 /* Other operators */
"**"  {return TOK_POW;}

[$]+  { yylval.SelfLevel = yyleng; return TOK_SELF;}

 /* Combination symbols */
"@"   {yylval.Combine = BOXCOMBTYPE_AT; return TOK_COMBINE;}
"(=)" {yylval.Combine = BOXCOMBTYPE_COPY; return TOK_COMBINE;}
 /* for compatibility with v 0.1 */
"@@"  {yylval.Combine = BOXCOMBTYPE_AT; return TOK_COMBINE;}
"@&"  {yylval.Combine = BOXCOMBTYPE_AT; return TOK_COMBINE;}

 /* Special tokens */
"(.[)" {yylval.TTag = BOXTYPEID_INIT;  return TOK_TTAG;}
"(].)" {yylval.TTag = BOXTYPEID_FINISH; return TOK_TTAG;}
"([)"  {yylval.TTag = BOXTYPEID_BEGIN; return TOK_TTAG;}
"(])"  {yylval.TTag = BOXTYPEID_END; return TOK_TTAG;}
"(;)"  {yylval.TTag = BOXTYPEID_PAUSE; return TOK_TTAG;}

 /* Number of type Char */
'(\\'|[^'\n]+)' {
  char val = '?';
  const char *err;

  err = Box_Expand_Escaped_Char(yytext + 1, yyleng - 2, & val);
  if (err)
    MY_TOK_ERR("%s.", err);
  yylval.Node = MY_NODE(CharImm, val);
  return TOK_CONSTANT;
 }

 /* Integer number */
{DIGIT}+ {
  BoxInt val = 1;
  const char *err;

  err = Box_Str_To_Int(yytext, yyleng, & val);
  if (err)
    MY_TOK_ERR("%s.", err);
  yylval.Node = MY_NODE(IntImm, val);
  return TOK_CONSTANT;
 }

 /* Integer number in hexadecimal notation */
[0][xX]{HEXDIGIT}+ {
  BoxInt val = 1;
  const char *err;

  err = Box_Hex_Str_To_Int(yytext + 2, yyleng - 2, & val);
  if (err)
    MY_TOK_ERR("%s.", err);
  yylval.Node = MY_NODE(IntImm, val);
  return TOK_CONSTANT;
 }

 /* Floating point number */
{DIGIT}+("."{DIGIT}+)?([eE][+-]?{DIGIT}+)? {
  BoxReal val = 1.0;
  const char *err;

  err = Box_Str_To_Real(yytext, yyleng, & val);
  if (err)
    MY_TOK_ERR("%s.", err);
  yylval.Node = MY_NODE(RealImm, val);
  return TOK_CONSTANT;
 }

 /* String */
{STRING} {
  char *out = NULL;
  size_t out_length = 0;
  const char *err;

  err = Box_Expand_Escaped_Str(yytext + 1, yyleng - 2, & out, & out_length);
  if (err)
    MY_TOK_ERR("%s.", err);

  yylval.Node = MY_NODE(StrImm, out, out_length);
  Box_Mem_Free(out);
  return TOK_STRING;
 }

Else {
  yylval.String = Box_Mem_Strndup(yytext, yyleng);
  return TOK_KEYWORD;
}

 /* Variable name */
{LNAME} {
  yylval.Node = MY_NODE(VarIdfr, yytext, yyleng);
  return TOK_VAR_IDFR;
 }

 /* Type name */
{UNAME} {
  yylval.Node = MY_NODE(TypeIdfr, yytext, yyleng);
  BoxASTNode_Set_Attr(yylval.Node, 0, BOXASTNODEATTR_TYPE);
  return TOK_TYPE_IDFR;
 }

 /* Everything which is not recognised is passed character by character to the
  * parser.
  */
. {return yytext[0];}

%%

#include "parser.c"

int BoxParser_Get_Next_Token(BoxParser *bl)
{
  if (BoxArr_Num_Items(& bl->include_list) > 0)
    return yylex(bl->scanner);
  else
    MSG_FATAL("BoxParser_Next_Token: the source file has not been specified. "
              "Use BoxParser_Begin_Include to set it.");
}

BoxBool BoxParser_Begin_Include_FILE(BoxParser *bl, FILE *f, const char *fn)
{
  size_t include_level = BoxArr_Num_Items(& bl->include_list);
  YY_BUFFER_STATE buffer;
  MyIncludeData *cur;

  if (include_level >= bl->max_include_level) {
    BoxParser_Log_Err(bl, "Cannot include \"%s\": too many files included!",
                      fn);
    return BOXBOOL_FALSE;
  }

  cur = BoxArr_Push(& bl->include_list, NULL);
  cur->pos = bl->pos;
  cur->script_dir = NULL;
  cur->msgcontext = 0; /*Msg_Context_Num(); TODO ??? */
  cur->num_errs = MSG_GT_ERRORS;
  cur->num_warns = MSG_NUM_WARNINGS;

  buffer = yy_create_buffer(f, YY_BUF_SIZE, bl->scanner);
  assert(buffer != NULL);
  yypush_buffer_state(buffer, bl->scanner);
  BoxSrcPos_Init(& bl->pos, BoxSrcName_Add(bl->fnames, fn));

  MSG_CONTEXT_BEGIN("Entering the included file \"%s\"", fn);
  return BOXBOOL_TRUE;
}

BoxBool BoxParser_End_Include(BoxParser *bl)
{
  size_t include_level = BoxArr_Num_Items(& bl->include_list);
  if (include_level > 0) {
    size_t num_errs, num_warns;
    MyIncludeData cur;

    /* Retrieve the last include data block and remove it from the stack */
    BoxArr_Pop(& bl->include_list, & cur);

    /* Return to the previous buffer and restore the previous position */
    yypop_buffer_state(bl->scanner);
    bl->pos = cur.pos;

    Box_Mem_Free(cur.script_dir);

    /* Compute the number of errors in the included file */
    num_errs = MSG_GT_ERRORS - cur.num_errs;
    num_warns = MSG_NUM_WARNINGS - cur.num_warns;
    MSG_ADVICE("Exiting from the included file. "
               "%U errors and %U warnings were found.",
               num_errs, num_warns);
    MSG_CONTEXT_END();
    return (include_level == 1);
  }

  return BOXBOOL_TRUE;
}

static void My_Fix_Pos(yyscan_t scanner)
{
  size_t i, tok_length = yyget_leng(scanner);
  const char *tok_text = yyget_text(scanner);
  BoxParser *box_lexer = yyget_extra(scanner);
  BoxSrcLine line = 0;
  BoxSrcCol col = 0;

  for(i = 0; i < tok_length; i++) {
    if (tok_text[i] == '\n') {
      col = 1;
      line += 1;
    } else
      col += 1;
  }

  /* Note: if line == 0, then there is nothing to fix, as the basic rule
   * of adding yyleng to box_lexer->pos.col gave already the right result.
   */
  if (line) {
    box_lexer->pos.line += line;
    box_lexer->pos.col = col;
  }
}

static void My_Comment_Enter(BoxParser *bl, int is_macro)
{
  ++bl->comment_level;
  assert(bl->comment_level != 0);

  bl->parsing_macro = is_macro;
  BoxArr_Empty(& bl->macro_content);
}

static int My_Comment_Leave(BoxParser *bl)
{
  assert(bl->comment_level > 0);
  --bl->comment_level;

  /* Parse the macro, if necessary */
  if (bl->parsing_macro) {
    BoxMacro bm;
    char line_term = '\0';
    BoxArr_Push(& bl->macro_content, & line_term);

    BoxMacro_Init(& bm, (char *) BoxArr_First_Item_Ptr(& bl->macro_content));
    BoxMacro_Parse(& bm);

    My_Process_Macro(bl, & bm);
    BoxMacro_Finish(& bm);
  }

  bl->parsing_macro = 0;
  return (bl->comment_level == 0);
}

static void My_Comment_Read_Char(BoxParser *bl, const char *text, size_t len)
{
  if (bl->parsing_macro)
    BoxArr_MPush(& bl->macro_content, text, len);
}

/** Parse an integer from the string 'text' and - if successful - put it into
 * '*arg' and return 1. Return 0 in case of errors.
 */
static int My_Parse_Int_Arg(const char *text, long int *arg)
{
  errno = 0;
  char *endptr;
  long int retval = strtol(text, & endptr, 10);
  if (errno == 0 && endptr != text && *endptr == '\0') {
    if (arg != NULL)
      *arg = retval;
    return 1;

  } else
    return 0;
}

/** Check that 'text' is a string of the type '"content"' and - if this is the
 * case - set '*arg' to the first character after " and substitutes the closing
 * " with a NUL (so that '*arg' is actually the content of the string).
 * 'text' is modified by a call to this function.
 */
static int My_Parse_Str_Arg(char *text, char **arg)
{
  size_t len = strlen(text);
  if (len > 2 && text[0] == '"' && text[len - 1] == '"') {
    text[len - 1] = '\0';
    *arg = & text[1];
    return 1;
  }
  return 0;
}

/* Process macros embedded in comments like (**macro: args*) */
static void My_Process_Macro(BoxParser *bl, BoxMacro *bm)
{
  const char *name = BoxMacro_Get_Name(bm);
  size_t num_args = BoxMacro_Get_Num_Args(bm);

  if (name && strcmp(name, "line") == 0) {
    long int arg1;
    if (num_args >= 1 && My_Parse_Int_Arg(BoxMacro_Get_Arg(bm, 0), & arg1)) {
      long int arg2;
      BoxSrcPos_Set_Line(& bl->pos, (arg1 > 0) ? arg1 : 0);

      if (num_args >= 2 && My_Parse_Int_Arg(BoxMacro_Get_Arg(bm, 1), & arg2)) {
        char *arg3;

        BoxSrcPos_Set_Col(& bl->pos, (arg2 > 0) ? arg2 : 0);

        if (My_Parse_Str_Arg(BoxMacro_Get_Arg(bm, 2), & arg3))
          BoxSrcPos_Set_File_Name(& bl->pos, BoxSrcName_Add(bl->fnames, arg3));
      }
    }
  }
}
