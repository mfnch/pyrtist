/***************************************************************************
 *   Copyright (C) 2006 by Matteo Franchin                                 *
 *   fnch@libero.it                                                        *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

/* $Id$ */


 /* This file contains the rules used by flex to create the tokenizer. */

 /* include e' una start-condition che serve per prelevare il nome del file
  * in una direttiva include
  */
%x include

%{

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "types.h"
#include "defaults.h"
#include "mem.h"
#include "ast.h"
#include "messages.h"
#include "array.h"
#include "str.h"
#include "virtmach.h"
#include "compiler.h"
#include "expr.h"
#include "tokenizer.h"
#include "parserh.h"
#include "parser.h" /* This is the file generated by yacc */
#include "builtins.h"
#include "fileutils.h"
#include "paths.h"
#include "hashtable.h"

/* Use our message handler */
#define YY_FATAL_ERROR(msg) MSG_FATAL("%s", msg)

/* Dati che servono per la gestione della direttiva "include" */
typedef struct {
  UInt linenum;
  UInt msgcontext;
  UInt num_errs, num_warns;
  YY_BUFFER_STATE buffer;
} TokIncludeData;

/* Variabili gestite in questo file */
UInt tok_linenum = 1;
static UInt tok_cur_include_level = 1, tok_max_include_level;
static BoxArr tok_include_list;
static BoxHT provided_features;

static int Tok_Provided(const char *feature, int length) {
  BoxHTItem *item;
  if (BoxHT_Find(& provided_features, (void *) feature, length, & item))
    return 1;
  BoxHT_Insert(& provided_features, (void *) feature, length);
  return 0;
}

%}

SPACES   [ \t]*
DIGIT    [0-9]
HEXDIGIT [0-9A-Fa-f]
NAME     [A-Za-z][A-Za-z0-9_]*
LNAME    [a-z][A-Za-z0-9_]*
UNAME    [A-Z][A-Za-z0-9_]*

%option noyywrap

%%

include BEGIN(include);

 /* Elimina gli spazi bianchi dopo la direttiva include */
<include>[ \t]*
 /* Cio' che segue include dopo gli eventuali spazi bianchi,
  * e' il nome del file: non sono consentiti commenti
  * o caratteri di continuazione riga sulla stessa riga di una include
  */
<include>["][^"\n]*["] {
  char *f = Str_Dup(yytext+1, yyleng-2);

  BEGIN(INITIAL);

  (void) Tok_Include_Begin(f);
  free(f);
}
 /* Tutto il resto da' errori! */
<include>. {
  BEGIN(INITIAL);
  return TOK_ERR;
}

 /* Se sto leggendo un file di include, quando arrivo alla sua fine
  * torno a leggere il precedente.
  */
<<EOF>> {
  if ( Tok_Include_End() ) {yyterminate();}
}

 /* Un istruzione deve stare tutta su una riga.
  * Se questo diventa problematico e' possibile usare il carattere
  * di continuazione riga _
  */
"\n"    {return TOK_NEWLINE;}

 /* Il carattere di continuazione riga mangia tutto ci che segue
  * fino alla nuova riga e annulla il carattere newline
  */
"_"{SPACES}"\n"       {++tok_linenum;}
"_"{SPACES}"'"[^\n]*"\n"  {++tok_linenum;}

 /* Scarta i commenti (i commenti iniziano col carattere '
  * e terminano alla fine della riga; per commenti su piu' righe
  * bisogna mettere un ' all'inizio di ogni riga di commento)
  */
"//"[^\n]*  {}
"#!"[^\n]*  {}

"#"{SPACES}"provide"{SPACES}["][^"\n]+["] {
  const char *feature = strchr(yytext, '"') + 1;
  int length = strchr(feature, '"') - feature - 1;
  if (Tok_Provided(feature, length)) {
    if (Tok_Include_End()) {yyterminate();}
  }
}

 /* Ignora gli spazi */
{SPACES}    {}


"->"  {return TOK_TO;}
"end" {return TOK_END;}

 /* Operatori di assegnazione */
"+="  { return TOK_APLUS; }
"-="  { return TOK_AMINUS; }
"*="  { return TOK_ATIMES; }
"%="  { return TOK_AREM; }
"/="  { return TOK_ADIV; }
"<<=" { return TOK_ASHL; }
">>=" { return TOK_ASHR; }
"&="  { return TOK_ABAND; }
"^="  { return TOK_ABXOR; }
"|="  { return TOK_ABOR; }

 /* Opertaori di incremento/decremento */
"++"  {return TOK_INC;}
"--"  {return TOK_DEC;}

 /* Opertaori di incremento/decremento */
"<<"  {return TOK_SHL;}
">>"  {return TOK_SHR;}

 /* Operatori di confronto */
"=="  { return TOK_EQ; }
"!="  { return TOK_NE; }
"<="  { return TOK_LE; }
">="  { return TOK_GE; }

"&&"  { return TOK_LAND; }
"||"  { return TOK_LOR; }

 /* Altri operatori */
"**"  { return TOK_POW; }

[$]+  { /*yylval.Int = yyleng;*/ return TOK_NPARENT; }

"@"   { /*yylval.kind = 1;*/ return TOK_AT; }

"@@"  { /*yylval.kind = 2; */return TOK_AT; }

"@&"  { /*yylval.kind = 3;*/ return TOK_AT; }

"([)" { /*yylval.proc = TYPE_OPEN;*/ return TOK_PROC; }

"(])" { /*yylval.proc = TYPE_CLOSE;*/ return TOK_PROC; }

"(;)" { /*yylval.proc = TYPE_PAUSE;*/ return TOK_PROC; }

"(\\)" { /*yylval.proc = TYPE_DESTROY;*/ return TOK_PROC; }

 /* Number of type Char */
[']([^'\n]|\\')+['] {
  AstConst c;
  if (Str_ToChar(yytext+1, yyleng-2, (char *) & c.c) == BoxFailure) {
    yylval.Node = AstNodeConst_New(ASTCONSTTYPE_CHAR, c);
    AstNode_Set_Error(yylval.Node);
  } else
    yylval.Node = AstNodeConst_New(ASTCONSTTYPE_CHAR, c);
  return TOK_CONSTANT;
 }

 /* for future use:
   [']    {}
   [']['] {}
  */

 /* Integer number */
{DIGIT}+ {
  AstConst c;
  if (Str_ToInt(yytext, yyleng, & c.i) == BoxFailure) {
    yylval.Node = AstNodeConst_New(ASTCONSTTYPE_INT, c);
    AstNode_Set_Error(yylval.Node);
  } else
    yylval.Node = AstNodeConst_New(ASTCONSTTYPE_INT, c);
  return TOK_CONSTANT;
 }

 /* Integer number in hexadecimal notation */
[0][xX]{HEXDIGIT}+ {
  AstConst c;
  if (Str_Hex_To_Int(yytext+2, yyleng-2, & c.i) == BoxFailure) {
    yylval.Node = AstNodeConst_New(ASTCONSTTYPE_INT, c);
    AstNode_Set_Error(yylval.Node);
  } else
    yylval.Node = AstNodeConst_New(ASTCONSTTYPE_INT, c);
  return TOK_CONSTANT;
 }

 /* Floating point number */
{DIGIT}+("."{DIGIT}+)?([eE][+-]?{DIGIT}+)? {
  AstConst c;
  if (Str_ToReal(yytext, yyleng, & c.r) == BoxFailure) {
    yylval.Node = AstNodeConst_New(ASTCONSTTYPE_REAL, c);
    AstNode_Set_Error(yylval.Node);
  } else
    yylval.Node = AstNodeConst_New(ASTCONSTTYPE_REAL, c);
  return TOK_CONSTANT;
 }

 /* String */
["]([^"\n]|\\\")*["] {
  yylval.Node = AstNodeString_New(yytext + 1, yyleng - 2);
  return TOK_STRING;
 }

 /* Nome di variabile */
{LNAME} {
  yylval.String = BoxMem_Strndup(yytext, yyleng);
  return TOK_IDENTIFIER;
 }

 /* Nome di variabile */
{UNAME} {
  yylval.String = BoxMem_Strndup(yytext, yyleng);
  return TOK_TYPE_IDENT;
 }

 /* Tutto il resto viene passato cosi' com'e' carattere per carattere al parser
  */
. {return yytext[0];}

%%

/* DESCRIZIONE: Prepara le funzioni di analisi lessicale del compilatore.
 *  Se f != NULL il compilatore partira' come se la prima istruzione
 *  del programma fosse una "include nomefile" dove nomefile e' la stringa
 *  a cui punta f.
 *  maxinc indica il numero massimo di file di include che possono essere
 *  aperti contemporaneamente.
 */
Task Tok_Init(UInt maxinc, const char *f) {
  tok_max_include_level = maxinc;

  /* La seguente variabile indica quanti file, aperti con include "nomefile",
   * non sono ancora stati chiusi
   */
  tok_cur_include_level = 0;

  /* Creo una lista dove salvare i buffer, ogni qual volta
   * incontro una include
   */
  BoxArr_Init(& tok_include_list, sizeof(TokIncludeData),
              TOK_TYPICAL_MAX_INCLUDE);

  BoxHT_Init_Default(& provided_features, 64);

  /* Se f == "nomefile" (e quindi f != NULL), eseguo una:
   * include "nomefile"
   */
  if (f == NULL) return Success;

  return Tok_Include_Begin(f);
}

/* DESCRIZIONE: Conclude l'analisi lessicale del compilatore.
 */
void Tok_Finish(void) {
  BoxHT_Finish(& provided_features);
  BoxArr_Finish(& tok_include_list);
}

/* DESCRIZIONE: Esegue materialmente la direttiva include,
 *  aprendo il file di nome f in lettura e deviando l'analisi lessicale
 *  su di esso. Bastera' poi eseguire tok_include_end() per ritornare al punto
 *  in cui la direttiva include aveva interrotto la lettura.
 */
Task Tok_Include_Begin(const char *f) {
  FILE *incfile;
  TokIncludeData cur;

  if (tok_cur_include_level >= tok_max_include_level) {
    MSG_ERROR("Cannot include \"%s\": too many file included!", f);
    return Failed;
  }

  incfile = Path_Open_Inc_File(f, "rt");

  if (incfile == NULL) {
    MSG_ERROR("\"%s\" <-- Cannot open this file!", f);
    return Failed;
  }

  cur.linenum = tok_linenum;
  cur.msgcontext = 0; /*Msg_Context_Num(); TODO ??? */
  cur.num_errs = MSG_GT_ERRORS;
  cur.num_warns = MSG_NUM_WARNINGS;
  cur.buffer = YY_CURRENT_BUFFER;
  BoxArr_Push(& tok_include_list, & cur);

  ++tok_cur_include_level;

  tok_linenum = 1;
  yy_switch_to_buffer(yy_create_buffer((yyin = incfile), YY_BUF_SIZE));

  MSG_CONTEXT_BEGIN("Entering the included file \"%s\"", f);
  return Success;
}

/* DESCRIZIONE: Conclude la lettura di un file incluso con "include",
 *  restituendo 1 se non ci sono piu' file da leggere, 0 se bisogna riprendere
 *  la lettura dall'istruzione seguente la "include".
 */
UInt Tok_Include_End(void) {
  if ( tok_cur_include_level > 0 ) {
    TokIncludeData cur;
    UInt num_errs, num_warns;

    /* Cancella il buffer corrente */
    yy_delete_buffer( YY_CURRENT_BUFFER );
    /* Imposta il nuovo buffer all'ultimo inserito nello "stack" */
    cur = *((TokIncludeData *) BoxArr_Last_Item_Ptr(& tok_include_list));
    tok_linenum = cur.linenum;
    yy_switch_to_buffer(cur.buffer);
    /* Cancella l'ultimo elemento dello stack */
    BoxArr_Pop(& tok_include_list, NULL);
    --tok_cur_include_level;
    /* Calcolo il numero di errori nel file incluso (+tutti i sotto-inclusi!) */
    num_errs = MSG_GT_ERRORS - cur.num_errs;
    num_warns = MSG_NUM_WARNINGS - cur.num_warns;
    MSG_ADVICE("Exiting from the included file. "
               "%U errors and %U warnings were found.",
               num_errs, num_warns );
    MSG_CONTEXT_END();
    return 0;

  } else
    return 1;
}

void Tok_Unput(int c) {unput(c);}
