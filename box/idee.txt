29/11/2008

# Resolution object
Resolution = ++Point
Point @0 Resolution[$$ = $]

Dpi = Resolution
Point @0 Dpi[$$ = $*1.2345678]

# Window object
Window = ++(Str type, Point size, res)
Point      @0 Window[.size = $]
Str        @0 Window[.type = $]
Resolution @0 Window[.res = $]

# Concrete realisation of a Window
Window' = WindowInstance



WindowInstance = ++Ptr
Window' = WindowInstance

# Operator overloading
Vec3 = ++(Real x, y, z)
Vec3.(+) = Vec3
Vec3@Vec3.(+)[$$.x = $$$.x + $.x, $$.y = $$$.y + $.y, $$.z = $$$.z + $.z]

(+) is identical to (+?)
there is however also (?+)

==============================================================================


a = Point[.x = 0.0, .y = 0.0, .z = 0.0]

Point := [.x := Real, .y := Real, .z := Real]
Point := [.x, .y, .z := Real]

Circle ~ [.center ~ Point, .radius ~ Real,

]


c = Circle[(0, 0), 7]


================================================================================
|                               VARIABILI LOCALI                               |
================================================================================
Appartengono solo alla sessione, cioe' nascono in corrispondenza del [
e muoiono quando arriva ]
Faccio un esempio:

[...
    [...
        a = Int

    ...]
    b = Real
    ' Qui a non esiste
...]
'Qui b non esiste

a e b sono variabili temporanee (vengono associate a registri locali)

================================================================================
|                             VARIABILI IMPLICITE                              |
================================================================================
Appartengono all'oggetto di sessione.
Faccio un esempio:

c = Circle[ .radius = 1.45 ]
Print[ "Il raggio di c e' ", c.radius, " = 1.45" ]

================================================================================
|                        VARIABILI GLOBALI DI SESSIONE                         |
================================================================================
Hanno un'esistenza autonoma, ma sono visibili all'interno di una sessione,
oppure specificando la loro
Faccio un esempio:

a = b = c = Int
d = e = Real
f ~ Real
g = f

d = a

--------------------------------------------------------------------

Ogni espressione ha un tipo ben definito, ma non e' detto che abbia anche
un valore definito. Ad esempio:

* le espressioni 1 o (2*5 + 3)*2 hanno tipo intero e hanno dei valori ben
definiti (1 e 26 rispettivamente). Le espressioni 1.234 e 3.1415 + 1 sono
di tipo reale ed hanno anch'esse valori ben definiti.
Anche espressioni come Int[1.24] hanno definiti sia tipo (intero) che valore.

* espressioni come Int invece hanno tipo (intero in questo caso),
ma non hanno valore!

Quindi in un'assegnazione possiamo avere 2 casi:
1) a = b = Int --> definisce 2 nuove variabili a e b di tipo intero, senza
associare ad esse alcun valore.
2) c = d = 123 oppure c = d = Int[123] --> definisce 2 nuove variabili intere
entrambe aventi valore pari a 123.

NOTA: L'espressione a = 1 ha sia tipo (intero) che valore (1), pertanto
e' possibile scrivere a = b = 1. Le due seguenti istruzioni produrranno
tuttavia un output diverso:
print[1]
print[a = 1]
Infatti l'espressione a = 1 viene ignorata dalla box print (e da qualsiasi
altra box), la quale non produce alcun output.
Questa e' una convenzione comoda. Se si desidera che l'espressione a = 1
non venga ignorata, basta racchiuderla fra parentesi (...).
Le seguenti due istruzioni producono lo stesso output:
print[1]
print[(a = 1)]

Come si e' visto l'assegnazione e' il modo per creare-definire nuove variabili.
L'assegnazione vista (quella con l'operatore =) e' l'assegnazione di
tipo-valore. Esiste pero' anche un altro tipo di assegnazione, l'assegnazione
di significato, che si compie con l'operatore ->:
Naturale -> Int[0]
definisce Naturale come sinonimo del tipo Int, ???inizializzato a 0???, cosicche':
a = b = Naturale

OSSERVAZIONE SULLE SESSIONI:
Una sessione e' allo stesso tempo: un'unita' di codice,
un (oggetto/struttura dati), un tipo di dato.
Usando Int la sessione Int non inizia. Quindi viene restituito
solo un tipo senza valore. Affinche' la sessione inizi bisogna includere
le parentesi quadre [...].
In tal caso viene eseguito il codice dentro [...] e viene restituito
un oggetto


N = 5
fattoriale_di_N = Int[ for (i = j = Int 1, i <= N, i++) \ j *= i, j ]
fattoriale_di_N = Int[ j = 1, for (i = 2, i <= N, i++) j *= i, j ]

Fattoriale[Int N] := Int[ j = 1, for (i = 2, i <= N, i++) j *= i, j ]
Fattoriale[Int N, Real] := Real[...]



Fattoriale[Int]
Fattoriale[Real]


Put[ figura, "tr", .near[1, (3, 4)], .near[2, (4, 5)], .do, Print .rotation ]


w = window[.resx = 100, .type = "fig"]


alloc vo1, ...
mov rr1, 100
mov ro0, vo1
mov real[ro0+...], rr1

str ro1, "fig"
mov obj[ro0+...], ro1

oppure

str ro1, "fig"
scp ptr[ro0+...], ro1

________________________________________________________________________________

define::

define:const: pi = 3.1415926

const: (
	define: pi = 3.1415926
	define: pi_x_2 = 2*pi
)

const:define: (
	pi = 3.1415926
	pi_x_2 = 2*pi
)



const: pi = 3.1415926

r5 = repeat(5)
r5( print("ciao") )

repeat(5)(print(ciao))

================================================================================
|                                  PROBLEMI                                    |
================================================================================

/* Codice brutto! Mi aspetto che il compilatore dia un warning!
 * (del tipo: "La variabile 'a' ha significati diversi all'interno della stessa box!")
 */
[
  a = int[0]

  [
    a = 3
    a: = 4 /* Da qui in poi la variabile a, definita nella box precedente
            * non e' piu' visibile perche' nascosta dalla variabile a
            * appartenente alla box corrente e definita in questa riga!
            */
  ]
]
